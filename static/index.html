<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>quick-clip</title>
  <style>
    :root {
      --bg: #0f1226;
      --ink: #f2f5ff;
      --muted: #aeb4d4;
      --panel: #171c3a;
      --accent: #53f1ff;
      --accent2: #7cffaf;
      --danger: #ff7a7a;
      --border: #2a3472;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Trebuchet MS", "Avenir Next", "Segoe UI", sans-serif;
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 24px;
      background:
        radial-gradient(1200px 600px at 10% -10%, #202b6a55 0%, transparent 60%),
        radial-gradient(900px 420px at 90% 110%, #2a6bff33 0%, transparent 50%),
        linear-gradient(140deg, #0b0f29, #0a0f2a 40%, #11173b 100%);
      color: var(--ink);
    }
    .app {
      width: min(900px, 100%);
      background: linear-gradient(180deg, #1a2048, #171c3e);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 22px 60px #0008;
    }
    h1 {
      margin: 0 0 8px;
      letter-spacing: .3px;
    }
    .hint {
      margin: 0 0 14px;
      color: var(--muted);
    }
    .tabs {
      display: flex;
      gap: 8px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px;
      margin-bottom: 16px;
    }
    .tab-btn {
      border: 0;
      background: #0f1735;
      color: var(--muted);
      border: 1px solid #2b356e;
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
    }
    .tab-btn.active {
      color: #0b102e;
      font-weight: 700;
      background: linear-gradient(120deg, var(--accent), var(--accent2));
      border-color: transparent;
    }
    .panel { display: none; }
    .panel.active { display: block; }
    .status {
      margin-bottom: 12px;
      min-height: 1.4em;
      color: var(--muted);
      font-size: 14px;
      border-radius: 8px;
      padding: 6px 8px;
      border: 1px solid transparent;
      transition: background-color .2s, color .2s, border-color .2s;
      background: transparent;
    }
    .status:empty {
      min-height: 0;
      margin-bottom: 0;
      padding: 0;
      border-color: transparent;
    }
    .status.error {
      color: var(--danger);
      border-color: #5b243d;
      background: #2a1220;
    }

    .zone {
      border: 2px dashed var(--border);
      border-radius: 14px;
      padding: 26px;
      text-align: center;
      background: #10173f;
      transition: transform .15s, border-color .15s, background .15s;
    }
    .zone:hover {
      border-color: var(--accent);
      background: #121c49;
      transform: translateY(-2px);
    }
    .zone.drag { border-color: var(--accent2); background: #12354f; }
    .zone input[type=file] { display: none; }

    .btn {
      border: 0;
      color: #0b102e;
      background: linear-gradient(120deg, var(--accent), var(--accent2));
      font-weight: 700;
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .btn[disabled] { opacity: .6; cursor: not-allowed; }
    .row {
      margin-top: 14px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .url {
      flex: 1;
      background: #0c1230;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 12px;
      font-size: 14px;
      color: #ecf1ff;
      word-break: break-all;
      min-height: 18px;
    }
    .preview {
      margin-top: 16px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0d1233;
      display: none;
      max-width: 100%;
      border-radius: 10px;
      padding: 8px;
    }
    .preview img {
      width: 100%;
      max-height: 360px;
      object-fit: contain;
      border-radius: 8px;
      display: block;
      background: #050814;
    }
    .gallery-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .gallery-head .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }
    .gallery-title {
      margin: 0;
      font-size: 16px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .meta {
      color: var(--muted);
      font-size: 12px;
    }
    .list {
      display: grid;
      gap: 8px;
    }
    .list.grid-view {
      grid-template-columns: repeat(2, minmax(0, 1fr));
      align-items: start;
    }
    .list.grid-view .item {
      width: auto;
    }
    .list.grid-view .gallery-item-main {
      display: grid;
      grid-template-columns: 22px 64px 1fr;
      gap: 10px;
      align-items: center;
    }
    .list.list-view .item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      width: 100%;
      padding: 10px;
    }
    .list.list-view .gallery-item-main {
      display: flex;
      gap: 10px;
      align-items: center;
      width: 100%;
    }
    .list.list-view .item-content {
      width: 100%;
      min-width: 0;
      gap: 6px;
    }
    .list.list-view .item-meta {
      line-height: 1.35;
    }
    .list.list-view .item-row {
      display: flex;
      justify-content: flex-end;
      width: 100%;
      margin-top: 2px;
      margin-left: auto;
    }
    .list.list-view .item-link {
      min-width: 0;
      width: auto;
    }
    .list.list-view .thumb {
      width: 58px;
      height: 58px;
    }
    .list.list-view .item-main .item-link {
      width: 100%;
      overflow-wrap: anywhere;
    }
    .view-toggle {
      display: none;
    }
    .view-btn {
      border: 1px solid #2b356e;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
      background: #121b3f;
      color: var(--muted);
      font-weight: 700;
    }
    .view-btn.active {
      color: #0b102e;
      background: linear-gradient(120deg, var(--accent), var(--accent2));
      border-color: transparent;
    }
    .empty {
      color: var(--muted);
      font-size: 13px;
      padding: 12px 2px;
    }
    .item {
      background: #0b1434;
      border: 1px solid #23306c;
      border-radius: 8px;
      padding: 10px;
    }
    .item-main {
      display: grid;
      grid-template-columns: 64px 1fr;
      gap: 10px;
      align-items: center;
    }
    .item-select {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      flex: 0 0 auto;
      margin: 0;
      justify-self: center;
      cursor: pointer;
    }
    .item-main .item-link {
      min-width: 0;
      width: 100%;
      display: block;
      overflow-wrap: anywhere;
    }
    .thumb {
      width: 64px;
      height: 64px;
      object-fit: cover;
      border-radius: 8px;
      border: 1px solid #1d2559;
      background: #0d1437;
      cursor: zoom-in;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .item-content { display: flex; flex-direction: column; gap: 8px; }
    .item-row {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    #recent-list .item-row {
      justify-content: flex-end;
      width: 100%;
    }
    .item-link {
      color: #9ee9ff;
      text-decoration: none;
      word-break: break-all;
      min-width: 0;
      flex: 1;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .item-meta {
      color: var(--muted);
      font-size: 12px;
    }
    .small-btn {
      font-size: 12px;
      padding: 6px 10px;
      font-weight: 700;
      border: 0;
      border-radius: 8px;
      color: #e8eeff;
      background: #152157;
      border: 1px solid #2a3a8a;
      cursor: pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .small-btn[disabled] {
      opacity: .6;
      cursor: not-allowed;
    }
    .small-btn.secondary {
      color: #e8eeff;
      background: #152157;
      border: 1px solid #2a3a8a;
    }
    .danger {
      color: #fff;
      background: linear-gradient(120deg, #ff5f5f, #ff8080);
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: #000a;
      display: none;
      opacity: 0;
      transition: opacity 0.18s ease;
      place-items: center;
      z-index: 30;
      backdrop-filter: blur(1px);
    }
    .modal-backdrop[aria-hidden="false"] {
      display: grid;
      opacity: 1;
    }
    .modal-panel {
      width: min(420px, 90%);
      background: linear-gradient(180deg, #161c42, #121833);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 18px;
      box-shadow: 0 16px 46px #000a;
      transform: translateY(6px) scale(0.985);
      opacity: 0;
      transition: transform 0.2s ease, opacity 0.2s ease;
      -webkit-overflow-scrolling: touch;
    }
    .modal-panel h3 {
      margin: 0 0 8px;
      font-size: 18px;
    }
    .modal-panel p {
      margin: 0 0 12px;
      color: var(--muted);
      line-height: 1.45;
      font-size: 14px;
      word-break: break-all;
    }
    .modal-actions {
      display: flex;
      width: 100%;
      justify-content: flex-end;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .modal-actions .small-btn {
      white-space: nowrap;
    }
    .modal-backdrop[hidden] {
      display: none;
    }
    .modal-backdrop:not([hidden]) .modal-panel {
      transform: translateY(0) scale(1);
      opacity: 1;
    }
    .image-modal .modal-panel {
      width: min(920px, 95vw);
      max-height: calc(95vh - 12px);
      overflow: auto;
    }
    #image-modal-img {
      width: 100%;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 8px;
      background: #050814;
    }
    .image-modal-caption {
      margin: 10px 0 0;
      color: var(--muted);
      font-size: 13px;
      word-break: break-all;
    }
    .image-editor {
      position: relative;
      margin-top: 10px;
      display: none;
    }
    .image-editor[aria-hidden="false"] {
      display: block;
    }
    .image-editor-tools {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }
    .image-editor-tool-btn {
      background: #152157;
      border: 1px solid #2a3a8a;
    }
    .image-editor-tool-btn.active {
      color: #0b102e;
      background: linear-gradient(120deg, var(--accent), var(--accent2));
      border-color: transparent;
    }
    .image-editor-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
    }
    .image-editor-controls label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .image-editor-controls input[type="color"] {
      border: 0;
      width: 36px;
      height: 28px;
      padding: 0;
      background: transparent;
    }
    .image-editor-controls input[type="range"] {
      width: 130px;
    }
    .image-editor-canvas {
      width: 100%;
      height: auto;
      border: 1px solid #2a356e;
      border-radius: 8px;
      background: #050814;
      display: block;
      margin-top: 8px;
      touch-action: none;
    }
    .image-editor-text-input {
      position: absolute;
      z-index: 5;
      margin: 0;
      padding: 5px 8px;
      border: 1px solid #2a3a8a;
      border-radius: 6px;
      min-width: 150px;
      max-width: 360px;
      font-size: 18px;
      color: #e8eeff;
      background: #101d4d;
      caret-color: #fff;
      outline: none;
      box-shadow: 0 10px 24px #000a;
      font-family: "Trebuchet MS", "Avenir Next", "Segoe UI", sans-serif;
    }
    .image-editor-status {
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
    }
    .recent-section {
      margin-top: 16px;
    }
    .recent-title {
      margin: 0 0 6px;
      color: var(--muted);
      font-size: 14px;
      font-weight: 700;
    }
    .zone p,
    .hint,
    .status,
    .meta {
      text-wrap: pretty;
    }
    html,
    body {
      text-size-adjust: 100%;
      -webkit-text-size-adjust: 100%;
    }
    .list,
    .recent-section,
    .modal-backdrop,
    .app {
      -webkit-overflow-scrolling: touch;
    }

    @media (max-width: 768px) {
      body {
        padding: 12px;
      }
      .app {
        width: 100%;
        border-radius: 14px;
        padding: 14px;
        padding-bottom: calc(14px + env(safe-area-inset-bottom, 0px));
      }
      h1 {
        font-size: 1.4rem;
      }
      .hint {
        font-size: 13px;
      }
      .zone {
        padding: 18px 14px;
      }
      .btn {
        min-height: 38px;
      }
      .small-btn {
        min-height: 34px;
        padding-top: 8px;
        padding-bottom: 8px;
      }
      .status {
        font-size: 13px;
        position: sticky;
        top: 2px;
        z-index: 2;
        box-shadow: 0 6px 18px #0004;
      }
      .url {
        min-height: 42px;
      }
      .row {
        gap: 6px;
      }
      .tabs {
        gap: 6px;
      }
      .tab-btn,
      .view-btn {
        min-height: 38px;
      }
      .gallery-item-main {
        grid-template-columns: 22px 54px 1fr;
        gap: 8px;
      }
      .thumb {
        width: 54px;
        height: 54px;
      }
      .modal-panel {
        width: min(520px, 92vw);
        padding: 14px 12px;
      }
      .modal-actions {
        gap: 6px;
      }
      .gallery-head .row,
      .row {
        align-items: stretch;
      }
      .item-row {
        gap: 6px;
      }
      .gallery-title {
        gap: 2px;
      }
      .image-modal .modal-panel {
        max-height: 90vh;
      }
      .image-modal .modal-panel img {
        max-height: calc(90vh - 190px);
      }
      .item-content {
        min-width: 0;
      }
    }

    @media (max-width: 440px) {
      body {
        padding: 8px;
      }
      .app {
        border-radius: 10px;
        padding: 10px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
      }
      .item-meta {
        font-size: 11px;
      }
      .meta {
        font-size: 11px;
      }
      .preview {
        margin-top: 12px;
        padding: 6px;
      }
      .status {
        font-size: 12px;
        top: 0;
      }
      .status,
      .empty {
        margin-bottom: 10px;
      }
      .item-row {
        justify-content: stretch;
        flex-direction: column;
        align-items: stretch;
      }
      .item-row .small-btn {
        width: 100%;
      }
      .item-main .item-link {
        min-width: 0;
      }
      .gallery-head {
        gap: 12px;
      }

      .gallery-head .row {
        gap: 6px;
      }

      .gallery-head .row > .small-btn,
      .gallery-head .row > .btn,
      .gallery-head .view-btn,
      .gallery-head .meta {
        width: auto;
      }

      .gallery-head .row > .small-btn,
      .gallery-head .row > .btn,
      .gallery-head #refresh-btn {
        min-width: 96px;
        text-align: center;
        justify-content: center;
      }

      .gallery-title {
        width: 100%;
      }
      .gallery-head .row {
        width: 100%;
      }
      .recent-title {
        font-size: 13px;
      }
      #copy-btn,
      .tab-btn {
        width: 100%;
      }
      #load-more,
      .url {
        width: 100%;
      }
      .modal-panel {
        width: min(520px, 100vw - 16px);
      }
      .modal-actions {
        justify-content: stretch;
      }
      .modal-actions .small-btn {
        width: 100%;
      }
      .modal-backdrop {
        padding: 8px;
      }
      .modal-panel h3 {
        font-size: 16px;
      }
      .image-modal-caption {
        font-size: 12px;
      }
      .image-modal #image-modal-close-btn {
        order: 1;
      }
    }

    @media (max-width: 360px) {
      .zone p {
        margin: 8px 0;
      }
      .zone {
        padding: 14px 10px;
      }
      .tabs {
        gap: 6px;
        flex-direction: column;
      }
      .tab-btn {
        width: 100%;
        min-height: 36px;
        font-size: 13px;
      }
      .item {
        padding: 8px;
      }
      .item-content {
        gap: 6px;
      }
      .item-row .small-btn {
        min-height: 36px;
      }
      .item-link {
        margin-bottom: 4px;
      }
      .image-modal .modal-panel {
        width: min(520px, 100vw - 10px);
        padding: 10px 8px;
      }
      .image-modal .modal-panel img {
        max-height: calc(82vh - 180px);
      }
      .modal-actions {
        gap: 6px;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        display: grid;
      }
      .modal-actions .small-btn {
        width: 100%;
        min-height: 36px;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>quick-clip</h1>
    <p class="hint">Upload images to create local URLs instantly and reuse them right away.</p>

    <div class="tabs">
      <button id="tab-upload" class="tab-btn active" type="button">Upload</button>
      <button id="tab-gallery" class="tab-btn" type="button">Gallery</button>
    </div>

    <div id="upload-panel" class="panel active">
      <div id="status-upload" class="status"></div>

      <div id="zone" class="zone">
        <p>Drop file here</p>
        <p>or</p>
        <label class="btn">
          Select file
          <input id="file-input" type="file" accept="image/*" multiple />
        </label>
      </div>

      <div class="row">
        <div id="url-box" class="url">Ready.</div>
        <button id="copy-btn" class="btn" disabled>Copy URL</button>
      </div>
      <div id="retry-row" class="row" style="margin-top: 8px; margin-bottom: 0;">
        <button id="retry-failed-btn" class="btn small-btn secondary" type="button" hidden>Retry failed uploads</button>
      </div>

      <div id="preview-box" class="preview">
        <img id="preview" alt="Uploaded preview" />
      </div>

      <section class="recent-section">
        <h3 class="recent-title">Latest uploads</h3>
        <div id="recent-status" class="status"></div>
        <div id="recent-list" class="list"></div>
      </section>
    </div>

    <div id="gallery-panel" class="panel">
      <div class="gallery-head">
        <div class="gallery-title">
          <span>All Images</span>
          <span id="gallery-summary" class="meta"></span>
        </div>
        <div class="row">
          <div class="view-toggle">
            <button id="view-grid-btn" class="view-btn active" type="button">Grid</button>
            <button id="view-list-btn" class="view-btn" type="button">List</button>
          </div>
          <span id="gallery-selected-count" class="meta">0 selected</span>
          <button id="gallery-select-all-btn" class="small-btn secondary" type="button" disabled>Select all</button>
          <button id="gallery-delete-selected-btn" class="small-btn danger" type="button" disabled>Delete selected</button>
          <button id="refresh-btn" class="btn small-btn" type="button">Refresh</button>
        </div>
      </div>
      <div id="gallery-status" class="status"></div>
      <div id="gallery-list" class="list"></div>
      <div class="row">
        <button id="load-more" class="btn small-btn" style="width: 100%; margin-top: 8px;" type="button" disabled>Load more</button>
      </div>
    </div>

    <div id="delete-modal" class="modal-backdrop" hidden role="dialog" aria-modal="true" aria-labelledby="delete-modal-title">
      <div class="modal-panel">
        <h3 id="delete-modal-title">Delete image</h3>
        <p>
          Are you sure you want to delete
          <strong id="delete-filename">this image</strong>?
        </p>
        <div class="modal-actions">
          <button id="delete-cancel-btn" class="btn small-btn secondary" type="button">Cancel</button>
          <button id="delete-confirm-btn" class="small-btn danger" type="button">Delete</button>
        </div>
      </div>
    </div>

    <div id="delete-selected-modal" class="modal-backdrop" hidden role="dialog" aria-modal="true" aria-labelledby="delete-selected-modal-title">
      <div class="modal-panel">
        <h3 id="delete-selected-modal-title">Delete selected images</h3>
        <p>
          Are you sure you want to delete
          <strong id="delete-selected-count">0 images</strong>?
          This cannot be undone.
        </p>
        <div class="modal-actions">
          <button id="delete-selected-cancel-btn" class="btn small-btn secondary" type="button">Cancel</button>
          <button id="delete-selected-confirm-btn" class="small-btn danger" type="button">Delete selected</button>
        </div>
      </div>
    </div>

    <div id="image-modal" class="modal-backdrop image-modal" hidden role="dialog" aria-modal="true" aria-labelledby="image-modal-title">
      <div class="modal-panel">
        <h3 id="image-modal-title">Image preview</h3>
        <img id="image-modal-img" alt="Image preview" />
        <p id="image-modal-filename" class="image-modal-caption"></p>

        <div id="image-editor" class="image-editor" aria-hidden="true">
          <div class="image-editor-tools">
            <button id="image-editor-tool-select" class="small-btn image-editor-tool-btn" type="button" title="Select (V)">Select (V)</button>
            <button id="image-editor-tool-brush" class="small-btn image-editor-tool-btn active" type="button" title="Pen (P)">Pen (P)</button>
            <button id="image-editor-tool-line" class="small-btn image-editor-tool-btn" type="button" title="Line (L)">Line (L)</button>
            <button id="image-editor-tool-rect" class="small-btn image-editor-tool-btn" type="button" title="Box (B)">Box (B)</button>
            <button id="image-editor-tool-text" class="small-btn image-editor-tool-btn" type="button" title="Text (T)">Text (T)</button>
          </div>
          <div class="image-editor-controls">
            <label for="image-editor-color">
              <span>Color</span>
              <input id="image-editor-color" type="color" value="#ff0000" />
            </label>
            <label for="image-editor-size">
              <span>Size</span>
              <input id="image-editor-size" type="range" min="1" max="48" value="7" />
              <span id="image-editor-size-text">7</span>
            </label>
          </div>
          <canvas id="image-editor-canvas" class="image-editor-canvas" hidden></canvas>
          <input
            id="image-editor-text-input"
            class="image-editor-text-input"
            type="text"
            autocomplete="off"
            spellcheck="false"
            placeholder="Type text and press Enter"
            hidden
          />
          <div class="modal-actions">
            <button id="image-editor-undo-btn" class="small-btn secondary" type="button" title="Undo (Ctrl/Cmd+Z)">Undo (Ctrl/Cmd+Z)</button>
            <button id="image-editor-clear-btn" class="small-btn secondary" type="button">Clear</button>
            <button id="image-editor-delete-btn" class="small-btn danger" type="button" title="Delete (Delete/Backspace)">Delete (Del/Backspace)</button>
            <button id="image-editor-save-btn" class="small-btn btn" type="button">Save</button>
            <button id="image-editor-cancel-btn" class="small-btn danger" type="button">Cancel</button>
          </div>
          <div class="image-editor-status" id="image-editor-status" aria-live="polite"></div>
        </div>

        <div class="modal-actions">
          <button id="image-modal-edit-btn" class="small-btn secondary" type="button">Edit</button>
          <button id="image-modal-copy-url-btn" class="small-btn secondary" type="button">Copy URL</button>
          <button id="image-modal-copy-image-btn" class="small-btn secondary" type="button">Copy Image</button>
          <button id="image-modal-open-btn" class="small-btn" type="button">Open URL</button>
          <button id="image-modal-close-btn" class="small-btn danger" type="button">Close</button>
        </div>
      </div>
    </div>
  </main>

  <script>
    const PAGE_LIMIT = 30;

    const tabUpload = document.getElementById("tab-upload");
    const tabGallery = document.getElementById("tab-gallery");
    const uploadPanel = document.getElementById("upload-panel");
    const galleryPanel = document.getElementById("gallery-panel");

    const zone = document.getElementById("zone");
    const fileInput = document.getElementById("file-input");
    const statusUpload = document.getElementById("status-upload");
    const statusGallery = document.getElementById("gallery-status");
    const urlBox = document.getElementById("url-box");
      const copyBtn = document.getElementById("copy-btn");
      const previewBox = document.getElementById("preview-box");
      const preview = document.getElementById("preview");
    const retryFailedBtn = document.getElementById("retry-failed-btn");

    const gallerySummary = document.getElementById("gallery-summary");
    const galleryList = document.getElementById("gallery-list");
    const refreshBtn = document.getElementById("refresh-btn");
    const gallerySelectedCount = document.getElementById("gallery-selected-count");
    const gallerySelectAllBtn = document.getElementById("gallery-select-all-btn");
    const galleryDeleteSelectedBtn = document.getElementById("gallery-delete-selected-btn");
    const loadMoreBtn = document.getElementById("load-more");
    const deleteModal = document.getElementById("delete-modal");
    const deleteFilename = document.getElementById("delete-filename");
    const deleteCancelBtn = document.getElementById("delete-cancel-btn");
    const deleteConfirmBtn = document.getElementById("delete-confirm-btn");
    const deleteSelectedModal = document.getElementById("delete-selected-modal");
    const deleteSelectedCount = document.getElementById("delete-selected-count");
    const deleteSelectedCancelBtn = document.getElementById("delete-selected-cancel-btn");
    const deleteSelectedConfirmBtn = document.getElementById("delete-selected-confirm-btn");
    const viewGridBtn = document.getElementById("view-grid-btn");
    const viewListBtn = document.getElementById("view-list-btn");
    const recentList = document.getElementById("recent-list");
    const recentStatus = document.getElementById("recent-status");
    const imageModal = document.getElementById("image-modal");
    const imageModalImg = document.getElementById("image-modal-img");
    const imageModalFilename = document.getElementById("image-modal-filename");
    const imageModalEditBtn = document.getElementById("image-modal-edit-btn");
    const imageModalCopyUrlBtn = document.getElementById("image-modal-copy-url-btn");
    const imageModalCopyImageBtn = document.getElementById("image-modal-copy-image-btn");
    const imageModalOpenBtn = document.getElementById("image-modal-open-btn");
    const imageModalCloseBtn = document.getElementById("image-modal-close-btn");
    const imageEditor = document.getElementById("image-editor");
    const imageEditorCanvas = document.getElementById("image-editor-canvas");
    const imageEditorStatus = document.getElementById("image-editor-status");
    const imageEditorToolSelectBtn = document.getElementById("image-editor-tool-select");
    const imageEditorToolBrushBtn = document.getElementById("image-editor-tool-brush");
    const imageEditorToolLineBtn = document.getElementById("image-editor-tool-line");
    const imageEditorToolRectBtn = document.getElementById("image-editor-tool-rect");
    const imageEditorToolTextBtn = document.getElementById("image-editor-tool-text");
    const imageEditorTextInput = document.getElementById("image-editor-text-input");
    const imageEditorColorInput = document.getElementById("image-editor-color");
    const imageEditorSizeInput = document.getElementById("image-editor-size");
    const imageEditorSizeText = document.getElementById("image-editor-size-text");
    const imageEditorUndoBtn = document.getElementById("image-editor-undo-btn");
    const imageEditorClearBtn = document.getElementById("image-editor-clear-btn");
    const imageEditorSaveBtn = document.getElementById("image-editor-save-btn");
    const imageEditorCancelBtn = document.getElementById("image-editor-cancel-btn");
    const imageEditorDeleteBtn = document.getElementById("image-editor-delete-btn");
    const deletePrevFocus = { target: null };

    let listOffset = 0;
    let isLoading = false;
    let isRecentLoading = false;
    let activeTab = "upload";
    let galleryViewMode = "list";
    let galleryNeedsRefresh = false;
    let deleteState = null;
    let isDeleteSelectedInProgress = false;
    let imageState = null;
    let imagePrevFocus = { target: null };
    const selectedAllFocus = { target: null };
    const gallerySelected = new Set();
    const galleryItemMap = new Map();
    const uploadQueue = [];
    const failedUploadQueue = [];
    let isUploadInProgress = false;
    const MAX_EDITOR_HISTORY = 20;
    const IMAGE_EDITOR_HIT_TOLERANCE = 10;
    const IMAGE_EDITOR_MIN_MOVE_PX = 2;
    const IMAGE_EDITOR_HANDLE_SIZE = 10;
    const IMAGE_EDITOR_HANDLE_TOLERANCE = 14;
    const IMAGE_EDITOR_HANDLE_DEBUG = new URLSearchParams(window.location.search).has("debugHandles");
    const IMAGE_EDITOR_MIN_SCALE = 0.1;
    const IMAGE_EDITOR_MAX_SCALE = 30;
    const IMAGE_EDITOR_SCALE_STEP = 1.12;
    const IMAGE_EDITOR_ROTATE_STEP_DEG = 8;
    const editorTools = {
      select: "select",
      brush: "brush",
      line: "line",
      rect: "rect",
      text: "text",
    };
    const editorState = {
      isOpen: false,
      filename: "",
      tool: editorTools.brush,
      color: imageEditorColorInput?.value || "#ff0000",
      strokeSize: 7,
      isDrawing: false,
      startX: 0,
      startY: 0,
      lastX: 0,
      lastY: 0,
      draftObject: null,
      draggingObjectId: null,
      dragBaseObject: null,
      dragMoved: false,
      dragMode: null,
      dragHandle: null,
      dragHandleStartAngle: 0,
      dragHandleStartDistance: 0,
      dragHandleStartScale: 1,
      pointerId: null,
      dragStartX: 0,
      dragStartY: 0,
      selectedObjectId: null,
      isTextInputOpen: false,
      textInputObjectId: null,
      isLoaded: false,
      history: [],
      maxHistory: MAX_EDITOR_HISTORY,
      context: null,
      naturalWidth: 0,
      naturalHeight: 0,
      image: null,
      objectIdCounter: 1,
      objects: [],
    };
    const allowed = (file) => file?.type.startsWith("image/");

    const setUploadStatus = (text, isError = false) => {
      statusUpload.textContent = text;
      statusUpload.classList.toggle("error", isError);
    };

    const setGalleryStatus = (text, isError = false) => {
      statusGallery.textContent = text;
      statusGallery.classList.toggle("error", isError);
    };

    const switchTab = (next) => {
      activeTab = next;
      const isUpload = next === "upload";
      tabUpload.classList.toggle("active", isUpload);
      tabGallery.classList.toggle("active", !isUpload);
      uploadPanel.classList.toggle("active", isUpload);
      galleryPanel.classList.toggle("active", !isUpload);
      localStorage.setItem("quick-clip-tab", next);
      if (!isUpload) {
        if (galleryNeedsRefresh || galleryList.children.length === 0) {
          galleryNeedsRefresh = false;
          loadList(false);
        }
      }
      if (isUpload) {
        loadRecentUploads();
      }
    };

    const formatBytes = (bytes) => {
      if (!bytes && bytes !== 0) return "unknown";
      const units = ["B", "KB", "MB", "GB"];
      let size = bytes;
      let i = 0;
      while (size >= 1024 && i < units.length - 1) {
        size /= 1024;
        i += 1;
      }
      return `${size.toFixed(size >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
    };

    const formatCreatedAt = (unixSeconds) => {
      const locale = navigator.language || "en-US";
      const date = new Date(unixSeconds * 1000);
      return new Intl.DateTimeFormat(locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
      }).format(date);
    };

    const getGalleryItemKey = (item) => {
      if (item?.url) return item.url;
      if (item?.filename && item?.created_at) return `${item.filename}|${item.created_at}`;
      if (item?.filename) return `${item.filename}|${item.size_bytes ?? 0}`;
      return "";
    };

    const syncGallerySelectionUi = () => {
      const selectedCount = gallerySelected.size;
      const hasSelection = selectedCount > 0;
      gallerySelectedCount.textContent = hasSelection
        ? `${selectedCount} selected`
        : "No images selected";
      galleryDeleteSelectedBtn.textContent = hasSelection
        ? `Delete selected (${selectedCount})`
        : "Delete selected";

      const itemCheckboxes = galleryList.querySelectorAll(".item-select");
      itemCheckboxes.forEach((checkbox) => {
        const key = checkbox.dataset.galleryItemKey;
        checkbox.checked = key ? gallerySelected.has(key) : false;
      });

      const keys = Array.from(galleryItemMap.keys());
      const allVisibleSelected = keys.length > 0 && keys.every((key) => gallerySelected.has(key));

      galleryDeleteSelectedBtn.disabled = !hasSelection;
      gallerySelectAllBtn.disabled = keys.length === 0;
      gallerySelectAllBtn.textContent = allVisibleSelected ? "Clear selection" : "Select all";
    };

    const createGallerySelectInput = (item) => {
      const checkbox = document.createElement("input");
      const key = getGalleryItemKey(item);

      checkbox.type = "checkbox";
      checkbox.className = "item-select";
      if (key) {
        checkbox.dataset.galleryItemKey = key;
      }
      checkbox.checked = key ? gallerySelected.has(key) : false;
      checkbox.setAttribute("aria-label", `Select ${item?.filename || "image"}`);
      checkbox.disabled = !key;
      checkbox.addEventListener("change", (event) => {
        const checked = event.currentTarget.checked;
        if (!key) return;
        if (checked) {
          gallerySelected.add(key);
        } else {
          gallerySelected.delete(key);
        }
        syncGallerySelectionUi();
      });
      return checkbox;
    };

    const openDeleteSelectedModal = () => {
      const selectedCount = gallerySelected.size;
      if (selectedCount === 0) return;
      selectedAllFocus.target = document.activeElement;

      deleteSelectedCount.textContent = `${selectedCount} ${selectedCount === 1 ? "image" : "images"}`;
      deleteSelectedModal.hidden = false;
      deleteSelectedModal.setAttribute("aria-hidden", "false");
      window.requestAnimationFrame(() => {
        deleteSelectedCancelBtn.focus();
      });
    };

    const closeDeleteSelectedModal = () => {
      deleteSelectedModal.hidden = true;
      deleteSelectedModal.setAttribute("aria-hidden", "true");
      if (selectedAllFocus.target && typeof selectedAllFocus.target.focus === "function") {
        selectedAllFocus.target.focus();
      }
      selectedAllFocus.target = null;
    };

    const openDeleteModal = (item, row, button) => {
      deleteState = { item, row, button };
      deletePrevFocus.target = document.activeElement;
      deleteFilename.textContent = item.filename;
      deleteModal.hidden = false;
      deleteModal.setAttribute("aria-hidden", "false");
      window.requestAnimationFrame(() => {
        deleteCancelBtn.focus();
      });
    };

    const closeDeleteModal = () => {
      deleteState = null;
      deleteModal.hidden = true;
      deleteModal.setAttribute("aria-hidden", "true");
      if (deletePrevFocus.target && typeof deletePrevFocus.target.focus === "function") {
        deletePrevFocus.target.focus();
      }
      deletePrevFocus.target = null;
    };

    const doDelete = async () => {
      if (!deleteState) return;
      const state = deleteState;
      const { item, row, button } = state;
      const previous = button.textContent;
      const key = getGalleryItemKey(item);

      closeDeleteModal();
      button.disabled = true;
      button.textContent = "Deleting...";
      row.style.opacity = "0.5";

      try {
        const encoded = encodeURIComponent(item.filename);
        const resp = await fetch(`/s/${encoded}`, { method: "DELETE" });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(data.detail || "Delete failed.");
        if (key) {
          gallerySelected.delete(key);
          galleryItemMap.delete(key);
          syncGallerySelectionUi();
        }
        setGalleryStatus(`Deleted ${item.filename}.`);
        loadRecentUploads();
        await resetList();
      } catch (err) {
        row.style.opacity = "1";
        setGalleryStatus(err.message || "Delete failed.", true);
      } finally {
        deleteState = null;
        button.disabled = false;
        button.textContent = previous;
        row.style.opacity = "1";
      }
    };

    const doDeleteSelectedGalleryImages = async () => {
      const count = gallerySelected.size;
      if (isDeleteSelectedInProgress || count === 0) return;
      const selectedKeys = [...gallerySelected];
      isDeleteSelectedInProgress = true;
      closeDeleteSelectedModal();
      galleryDeleteSelectedBtn.disabled = true;
      setGalleryStatus(`Deleting ${count} image${count === 1 ? "" : "s"}...`);

      let success = 0;
      let failed = 0;
      const failedNames = [];
      try {
        for (const key of selectedKeys) {
          const item = galleryItemMap.get(key);
          if (!item) {
            gallerySelected.delete(key);
            failed += 1;
            failedNames.push("Unknown file");
            continue;
          }

          try {
            const encoded = encodeURIComponent(item.filename);
            const resp = await fetch(`/s/${encoded}`, { method: "DELETE" });
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok) throw new Error(data.detail || "Delete failed.");
            galleryItemMap.delete(key);
            gallerySelected.delete(key);
            success += 1;
          } catch (err) {
            failed += 1;
            failedNames.push(item.filename || "Unknown file");
          }
        }

        if (failed > 0) {
          const failedDisplay = failedNames
            .slice(0, 2)
            .map((name) => `"${name}"`)
            .join(", ");
          const suffix = failedNames.length > 2 ? `, +${failedNames.length - 2} more` : "";
          const failedSummary = failedDisplay ? `${failedDisplay}${suffix}` : `${failed} file${failed === 1 ? "" : "s"}`;
          setGalleryStatus(`${success} image${success === 1 ? "" : "s"} deleted, ${failed} failed. Failed: ${failedSummary}`, true);
        } else {
          setGalleryStatus(`${success} image${success === 1 ? "" : "s"} deleted.`);
        }
        galleryNeedsRefresh = true;
        await loadRecentUploads();
        await resetList();
        galleryNeedsRefresh = false;
      } catch (err) {
        setGalleryStatus(err.message || "Failed to delete selected images.", true);
      } finally {
        galleryDeleteSelectedBtn.disabled = false;
        syncGallerySelectionUi();
        isDeleteSelectedInProgress = false;
      }
    };

    deleteCancelBtn.addEventListener("click", closeDeleteModal);
    deleteConfirmBtn.addEventListener("click", () => void doDelete());
    deleteSelectedCancelBtn.addEventListener("click", closeDeleteSelectedModal);
    deleteSelectedConfirmBtn.addEventListener("click", () => void doDeleteSelectedGalleryImages());
    deleteModal.addEventListener("click", (e) => {
      if (e.target === deleteModal) {
        closeDeleteModal();
      }
    });
    deleteSelectedModal.addEventListener("click", (e) => {
      if (e.target === deleteSelectedModal) {
        closeDeleteSelectedModal();
      }
    });
    imageModal.addEventListener("click", (e) => {
      if (e.target === imageModal) {
        closeImageModal();
      }
    });
    imageModalCloseBtn.addEventListener("click", closeImageModal);
    imageModalCopyUrlBtn.addEventListener("click", async () => {
      if (!imageState?.url) return;
      try {
        await copyImageUrlToClipboard(imageState);
      } catch (err) {
        applyCopyStatus(err.message || "Copy URL failed.", true);
      }
    });
    imageModalCopyImageBtn.addEventListener("click", async () => {
      if (!imageState?.url) return;
      try {
        await copyImageFileToClipboard(imageState);
      } catch (err) {
        applyCopyStatus(err.message || "Copy image failed.", true);
      }
    });
    imageModalEditBtn.addEventListener("click", () => {
      void startImageEditor();
    });
    imageModalOpenBtn.addEventListener("click", () => {
      if (!imageState?.url) return;
      window.open(imageState.url, "_blank", "noopener,noreferrer");
    });
    imageEditorToolSelectBtn?.addEventListener("click", () => setImageEditorTool(editorTools.select));
    imageEditorToolBrushBtn?.addEventListener("click", () => setImageEditorTool(editorTools.brush));
    imageEditorToolLineBtn?.addEventListener("click", () => setImageEditorTool(editorTools.line));
    imageEditorToolRectBtn?.addEventListener("click", () => setImageEditorTool(editorTools.rect));
    imageEditorToolTextBtn?.addEventListener("click", () => setImageEditorTool(editorTools.text));
    imageEditorTextInput?.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        event.preventDefault();
        hideImageEditorTextInput();
      } else if (event.key === "Enter") {
        event.preventDefault();
        commitImageEditorTextInput();
      }
    });
    imageEditorTextInput?.addEventListener("blur", () => {
      commitImageEditorTextInput();
    });
    imageEditorColorInput?.addEventListener("input", syncImageEditorInputs);
    imageEditorSizeInput?.addEventListener("input", syncImageEditorInputs);
    imageEditorUndoBtn?.addEventListener("click", () => {
      undoImageEdit();
    });
    imageEditorClearBtn?.addEventListener("click", () => {
      clearImageEdit();
    });
    imageEditorDeleteBtn?.addEventListener("click", () => {
      deleteSelectedEditorObject();
    });
    imageEditorSaveBtn?.addEventListener("click", () => {
      void uploadEditedImage();
    });
    imageEditorCancelBtn?.addEventListener("click", () => {
      closeImageEditor();
    });
    imageEditorCanvas?.addEventListener("pointerdown", handleEditorPointerDown);
    imageEditorCanvas?.addEventListener("pointermove", handleEditorPointerMove);
    imageEditorCanvas?.addEventListener("pointerup", handleEditorPointerUp);
    imageEditorCanvas?.addEventListener("pointercancel", handleEditorPointerUp);
    imageEditorCanvas?.addEventListener("pointerleave", handleEditorPointerUp);
    window.addEventListener("pointerup", handleEditorPointerUp);
    window.addEventListener("keydown", (e) => {
      const targetTag = e.target && e.target.tagName;
      const isTextField = targetTag && ["INPUT", "TEXTAREA"].includes(targetTag);
      if (e.key === "Escape") {
        if (editorState.isTextInputOpen) {
          e.preventDefault();
          hideImageEditorTextInput();
          return;
        }
        if (editorState.isOpen) {
          closeImageEditor();
          return;
        }
        if (!imageModal.hidden) {
          closeImageModal();
          return;
        }
        if (!deleteSelectedModal.hidden) {
          closeDeleteSelectedModal();
          return;
        }
        if (deleteState) {
          closeDeleteModal();
          return;
        }
      }
      if (!editorState.isOpen || isTextField) {
        return;
      }
      const key = e.key.toLowerCase();
      if (key === "v") {
        e.preventDefault();
        setImageEditorTool(editorTools.select);
        setImageEditorStatus("Select tool (V).");
        return;
      }
      if (key === "p") {
        e.preventDefault();
        setImageEditorTool(editorTools.brush);
        setImageEditorStatus("Pen tool (P).");
        return;
      }
      if (key === "l") {
        e.preventDefault();
        setImageEditorTool(editorTools.line);
        setImageEditorStatus("Line tool (L).");
        return;
      }
      if (key === "b") {
        e.preventDefault();
        setImageEditorTool(editorTools.rect);
        setImageEditorStatus("Box tool (B).");
        return;
      }
      if (key === "t") {
        e.preventDefault();
        setImageEditorTool(editorTools.text);
        setImageEditorStatus("Text tool (T).");
        return;
      }
      if ((e.ctrlKey || e.metaKey) && key === "z") {
        e.preventDefault();
        undoImageEdit();
        return;
      }
      const selected = editorState.objects.find((object) => object.id === editorState.selectedObjectId);
      if (selected) {
        if (key === "[") {
          e.preventDefault();
          const baseRotation = getEditorObjectRotation(selected);
          selected.rotation = ((baseRotation - IMAGE_EDITOR_ROTATE_STEP_DEG * Math.PI / 180) + Math.PI * 2) % (Math.PI * 2);
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Rotate -8.");
          return;
        }
        if (key === "]") {
          e.preventDefault();
          const baseRotation = getEditorObjectRotation(selected);
          selected.rotation = (baseRotation + IMAGE_EDITOR_ROTATE_STEP_DEG * Math.PI / 180) % (Math.PI * 2);
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Rotate +8.");
          return;
        }
        if (key === "+" || key === "=" || e.code === "NumpadAdd") {
          e.preventDefault();
          selected.scale = Math.min(IMAGE_EDITOR_MAX_SCALE, getEditorObjectScale(selected) * IMAGE_EDITOR_SCALE_STEP);
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Scale up.");
          return;
        }
        if (key === "-" || e.code === "NumpadSubtract") {
          e.preventDefault();
          selected.scale = Math.max(IMAGE_EDITOR_MIN_SCALE, getEditorObjectScale(selected) / IMAGE_EDITOR_SCALE_STEP);
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Scale down.");
          return;
        }
        if (key === "0") {
          e.preventDefault();
          selected.rotation = 0;
          selected.scale = 1;
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Transform reset.");
          return;
        }
      }
      if (false && selected) {
        if (key === "[") {
          e.preventDefault();
          const baseRotation = getEditorObjectRotation(selected);
          selected.rotation = ((baseRotation - IMAGE_EDITOR_ROTATE_STEP_DEG * Math.PI / 180) + Math.PI * 2) % (Math.PI * 2);
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Rotate -8°");
          return;
        }
        if (key === "]") {
          e.preventDefault();
          const baseRotation = getEditorObjectRotation(selected);
          selected.rotation = (baseRotation + IMAGE_EDITOR_ROTATE_STEP_DEG * Math.PI / 180) % (Math.PI * 2);
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Rotate +8°");
          return;
        }
        if (key === "+" || key === "=" || e.code === "NumpadAdd") {
          e.preventDefault();
          selected.scale = Math.min(IMAGE_EDITOR_MAX_SCALE, getEditorObjectScale(selected) * IMAGE_EDITOR_SCALE_STEP);
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Scale up.");
          return;
        }
        if (key === "-" || e.code === "NumpadSubtract") {
          e.preventDefault();
          selected.scale = Math.max(IMAGE_EDITOR_MIN_SCALE, getEditorObjectScale(selected) / IMAGE_EDITOR_SCALE_STEP);
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Scale down.");
          return;
        }
        if (key === "0") {
          e.preventDefault();
          selected.rotation = 0;
          selected.scale = 1;
          pushEditorHistory();
          renderImageEditor();
          setImageEditorStatus("Transform reset.");
          return;
        }
      }
      if (e.key === "Delete" || e.code === "Delete" || e.key === "Backspace" || e.key === "Del") {
        if (editorState.isTextInputOpen) {
          return;
        }
        e.preventDefault();
        deleteSelectedEditorObject();
      }
      if (key === "?") {
        e.preventDefault();
        setImageEditorStatus("Shortcuts: V(select), P(brush), L(line), B(rect), T(text), [ ], +/-, 0(reset), Delete/Backspace(remove), Esc(cancel text), Ctrl/Cmd+Z(undo).");
        return;
      }
    });

    const setGalleryViewMode = () => {
      galleryViewMode = "list";
      galleryList.classList.add("list-view");
      galleryList.classList.remove("grid-view");
    };

    const applyCopyStatus = (message, isError = false) => {
      if (activeTab === "upload") {
        setUploadStatus(message, isError);
      } else {
        setGalleryStatus(message, isError);
      }
    };

    const copyTextToClipboard = async (text) => {
      if (!text) {
        throw new Error("No text to copy.");
      }

      if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
        await navigator.clipboard.writeText(text);
        return;
      }

      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.setAttribute("readonly", "");
      textarea.style.position = "fixed";
      textarea.style.opacity = "0";
      textarea.style.left = "-9999px";
      textarea.style.top = "-9999px";
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();
      const succeeded = document.execCommand("copy");
      document.body.removeChild(textarea);

      if (!succeeded) {
        throw new Error("Clipboard API and fallback copy failed.");
      }
    };

    const copyImageUrlToClipboard = async (item) => {
      if (!item?.url) {
        throw new Error("No image URL available.");
      }
      await copyTextToClipboard(item.url);
      applyCopyStatus("Image URL copied.");
    };

    const copyImageFileToClipboard = async (item) => {
      if (!item?.url) {
        throw new Error("No image available.");
      }

      if (!navigator.clipboard || typeof ClipboardItem === "undefined") {
        throw new Error("This browser does not support image copy.");
      }

      const response = await fetch(item.url);
      if (!response.ok) {
        throw new Error("Failed to fetch image for clipboard copy.");
      }

      const blob = await response.blob();
      const mimeType = blob.type || "image/png";
      await navigator.clipboard.write([new ClipboardItem({ [mimeType]: blob })]);
      applyCopyStatus("Image copied to clipboard.");
    };

    const setImageEditorTool = (tool) => {
      editorState.tool = tool;
      const tools = {
        [editorTools.select]: imageEditorToolSelectBtn,
        [editorTools.brush]: imageEditorToolBrushBtn,
        [editorTools.line]: imageEditorToolLineBtn,
        [editorTools.rect]: imageEditorToolRectBtn,
        [editorTools.text]: imageEditorToolTextBtn,
      };
      Object.values(tools).forEach((button) => button?.classList.toggle("active", false));
      const selected = tools[tool];
      if (selected) selected.classList.add("active");
      if (tool === editorTools.select) {
        setImageEditorStatus("Select mode: click an object to move.");
      } else if (tool === editorTools.text) {
        setImageEditorStatus("Text mode: click on image to place text.");
      } else if (tool === editorTools.line) {
        setImageEditorStatus("Line mode: click and drag.");
      } else if (tool === editorTools.rect) {
        setImageEditorStatus("Box mode: click and drag.");
      } else {
        setImageEditorStatus("Pen mode: draw on image.");
      }
    };

    const setImageEditorStatus = (message) => {
      if (!imageEditorStatus) return;
      imageEditorStatus.textContent = message || "";
    };

    const hideImageEditorTextInput = () => {
      if (!imageEditorTextInput || !editorState.isTextInputOpen) return;
      imageEditorTextInput.hidden = true;
      imageEditorTextInput.value = "";
      imageEditorTextInput.dataset.objectId = "";
      imageEditorTextInput.dataset.x = "";
      imageEditorTextInput.dataset.y = "";
      editorState.isTextInputOpen = false;
      editorState.textInputObjectId = null;
      if (editorState.pointerId != null) {
        try {
          imageEditorCanvas?.releasePointerCapture(editorState.pointerId);
        } catch (_) {
          // ignore
        }
        editorState.pointerId = null;
      }
      editorState.isDrawing = false;
    };

    const findNearbyTextObjectForPosition = (position, matchText) => {
      if (!position) return null;
      const tolerance = Math.max(8, editorState.strokeSize + 2);
      for (let index = editorState.objects.length - 1; index >= 0; index -= 1) {
        const object = editorState.objects[index];
        if (!object || object.type !== editorTools.text) continue;
        if (object.text !== matchText) continue;
        if (Math.abs(object.x - position.x) > tolerance) continue;
        if (Math.abs(object.y - position.y) > tolerance) continue;
        return object;
      }
      return null;
    };

    const commitImageEditorTextInput = () => {
      if (!imageEditorTextInput || !editorState.isTextInputOpen) return;
      const text = (imageEditorTextInput.value || "").trim();
      const objectId = imageEditorTextInput.dataset.objectId || "";
      const x = Number(imageEditorTextInput.dataset.x);
      const y = Number(imageEditorTextInput.dataset.y);

      if (!text) {
        setImageEditorStatus("No change.");
        hideImageEditorTextInput();
        return;
      }

      const normalizedX = Number.isFinite(x) ? x : 0;
      const normalizedY = Number.isFinite(y) ? y : 0;
      const fontSize = Math.max(12, Math.round(editorState.strokeSize * 3));

      if (objectId) {
        const target = editorState.objects.find(
          (object) => object.id === objectId && object.type === editorTools.text,
        );
        if (target) {
          if (target.text !== text || target.fontSize !== fontSize || target.color !== editorState.color) {
            target.text = text;
            target.fontSize = fontSize;
            target.color = editorState.color;
            pushEditorHistory();
          }
          editorState.selectedObjectId = target.id;
          renderImageEditor();
          setImageEditorTool(editorTools.select);
          setImageEditorStatus("Text updated.");
        } else {
          const nearbyTarget = findNearbyTextObjectForPosition({ x: normalizedX, y: normalizedY }, text);
          if (nearbyTarget) {
            if (nearbyTarget.text !== text || nearbyTarget.fontSize !== fontSize || nearbyTarget.color !== editorState.color) {
              nearbyTarget.text = text;
              nearbyTarget.fontSize = fontSize;
              nearbyTarget.color = editorState.color;
              pushEditorHistory();
            }
            editorState.selectedObjectId = nearbyTarget.id;
            renderImageEditor();
            setImageEditorTool(editorTools.select);
            setImageEditorStatus("Text updated.");
          } else {
            setImageEditorStatus("Object not found.");
          }
        }
        hideImageEditorTextInput();
        return;
      }

      const nearbyTarget = findNearbyTextObjectForPosition({ x: normalizedX, y: normalizedY }, text);
      if (nearbyTarget) {
        if (nearbyTarget.text !== text || nearbyTarget.fontSize !== fontSize || nearbyTarget.color !== editorState.color) {
          nearbyTarget.text = text;
          nearbyTarget.fontSize = fontSize;
          nearbyTarget.color = editorState.color;
          pushEditorHistory();
        }
        editorState.selectedObjectId = nearbyTarget.id;
        renderImageEditor();
        setImageEditorTool(editorTools.select);
        setImageEditorStatus("Text updated.");
        hideImageEditorTextInput();
        return;
      }

      const textObject = {
        id: createEditorObjectId(),
        type: editorTools.text,
        x: normalizedX,
        y: normalizedY,
        color: editorState.color,
        fontSize,
        text,
        rotation: 0,
        scale: 1,
      };
      editorState.objects.push(textObject);
      editorState.selectedObjectId = textObject.id;
      pushEditorHistory();
      renderImageEditor();
      setImageEditorTool(editorTools.select);
      setImageEditorStatus("Text added.");
      hideImageEditorTextInput();
    };

    const openImageEditorTextInput = (position, targetObject = null) => {
      if (!editorState.isLoaded || !imageEditorCanvas || !imageEditorTextInput || !position) return;
      hideImageEditorTextInput();
      const canvasRect = imageEditorCanvas.getBoundingClientRect();
      const editorRect = imageEditor.getBoundingClientRect();
      const x = Math.max(0, Math.min(editorState.naturalWidth, position.x));
      const y = Math.max(0, Math.min(editorState.naturalHeight, position.y));
      const text = targetObject?.type === editorTools.text ? targetObject.text || "" : "";
      const fontSize = Math.max(12, Math.round(editorState.strokeSize * 3));
      const leftFromClick = Number.isFinite(position.clientX) ? Math.round(position.clientX - editorRect.left) : null;
      const topFromClick = Number.isFinite(position.clientY) ? Math.round(position.clientY - editorRect.top) : null;
      const leftFromScale = Math.round(canvasRect.left - editorRect.left + (x / editorState.naturalWidth) * canvasRect.width);
      const topFromScale = Math.round(canvasRect.top - editorRect.top + (y / editorState.naturalHeight) * canvasRect.height);
      const left = leftFromClick != null ? leftFromClick : leftFromScale;
      const top = topFromClick != null ? topFromClick : topFromScale;
      const charWidthEstimate = Math.max(7, Math.round(fontSize * 0.6));
      const expectedWidth = Math.min(360, Math.max(150, (text.length + 6) * charWidthEstimate));
      let safeLeft = left;
      const leftBound = imageEditor.clientWidth - expectedWidth - 8;
      if (safeLeft < 8) {
        safeLeft = 8;
      }
      if (safeLeft > leftBound) {
        safeLeft = leftBound;
      }
      safeLeft = Math.round(safeLeft);
      let safeTop = top;
      const topBound = imageEditor.clientHeight - 40;
      if (safeTop < 8) {
        safeTop = 8;
      }
      if (safeTop > topBound) {
        safeTop = topBound;
      }
      safeTop = Math.round(safeTop);

      imageEditorTextInput.value = text;
      imageEditorTextInput.style.fontSize = `${fontSize}px`;
      imageEditorTextInput.style.width = `${expectedWidth}px`;
      imageEditorTextInput.style.left = `${safeLeft}px`;
      imageEditorTextInput.style.top = `${safeTop}px`;
      imageEditorTextInput.dataset.objectId = targetObject?.id || "";
      imageEditorTextInput.dataset.x = String(x);
      imageEditorTextInput.dataset.y = String(y);
      editorState.textInputObjectId = targetObject?.id || null;
      editorState.isTextInputOpen = true;
      imageEditorTextInput.hidden = false;
      imageEditorTextInput.focus();
      imageEditorTextInput.select();
      setImageEditorStatus(targetObject?.type === editorTools.text ? "Edit text. Press Enter to confirm, Esc to cancel." : "Type text. Press Enter to confirm, Esc to cancel.");
    };

    const createEditorObjectId = () => `obj-${editorState.objectIdCounter++}`;

    const cloneEditorObject = (object) => {
      if (!object) return null;
      const copy = { ...object };
      if (object.type === editorTools.brush && Array.isArray(object.points)) {
        copy.points = object.points.map((point) => ({ ...point }));
      }
      return copy;
    };

    const syncEditorObjectCounter = () => {
      const maxId = editorState.objects.reduce((acc, object) => {
        if (!object?.id) return acc;
        const raw = String(object.id).replace(/^obj-/, "");
        const value = parseInt(raw, 10);
        return Number.isFinite(value) ? Math.max(acc, value) : acc;
      }, 0);
      editorState.objectIdCounter = Math.max(editorState.objectIdCounter, maxId + 1);
    };

    const createEditorSnapshot = () => ({
      objects: editorState.objects.map(cloneEditorObject),
      selectedObjectId: editorState.selectedObjectId,
    });

    const restoreEditorSnapshot = (snapshot) => {
      editorState.objects = (snapshot?.objects || []).map(cloneEditorObject);
      editorState.selectedObjectId = snapshot?.selectedObjectId || null;
      if (editorState.selectedObjectId && !editorState.objects.some((object) => object.id === editorState.selectedObjectId)) {
        editorState.selectedObjectId = null;
      }
      syncEditorObjectCounter();
    };

    const pushEditorHistory = () => {
      editorState.history.push(createEditorSnapshot());
      if (editorState.history.length > editorState.maxHistory) {
        editorState.history.shift();
      }
    };

    const restoreEditorFromHistory = (target = editorState.history.length - 1) => {
      if (!editorState.history.length) return;
      const index = Math.min(Math.max(target, 0), editorState.history.length - 1);
      restoreEditorSnapshot(editorState.history[index]);
      editorState.history = editorState.history.slice(0, index + 1);
      renderImageEditor();
    };

    const normalizeRect = (x, y, width, height) => {
      const normalizedX = width < 0 ? x + width : x;
      const normalizedY = height < 0 ? y + height : y;
      return {
        x: normalizedX,
        y: normalizedY,
        width: Math.abs(width),
        height: Math.abs(height),
      };
    };

    const renderImageEditor = () => {
      if (!editorState.context || !editorState.image) return;
      const context = editorState.context;
      context.clearRect(0, 0, editorState.naturalWidth, editorState.naturalHeight);
      context.drawImage(editorState.image, 0, 0, editorState.naturalWidth, editorState.naturalHeight);
      editorState.objects.forEach((object) => {
        renderEditorObject(context, object);
      });
      if (editorState.draftObject) {
        renderEditorObject(context, editorState.draftObject);
      }
      const selectedObject = editorState.objects.find((object) => object.id === editorState.selectedObjectId);
      if (selectedObject) {
        renderEditorSelection(context, selectedObject);
      }
      imageEditorCanvas.hidden = false;
      imageEditor.setAttribute("aria-hidden", "false");
    };

    const startImageEditor = async () => {
      if (!imageState?.url || !imageEditorCanvas || !imageEditor) {
        return;
      }
      setImageEditorStatus("Loading image...");
      hideImageEditorTextInput();
      imageModalEditBtn.disabled = true;
      imageModalImg.hidden = true;
      imageEditor.setAttribute("aria-hidden", "false");

      const defaultEditorColor = "#ff0000";
      const defaultEditorStrokeSize = 7;
      const parsedEditorStrokeSize = parseInt(imageEditorSizeInput?.value, 10);
      editorState.color = imageEditorColorInput?.value || defaultEditorColor;
      editorState.strokeSize = Number.isFinite(parsedEditorStrokeSize) && parsedEditorStrokeSize > 0 ? parsedEditorStrokeSize : defaultEditorStrokeSize;
      if (imageEditorColorInput) {
        imageEditorColorInput.value = editorState.color;
      }
      if (imageEditorSizeInput) {
        imageEditorSizeInput.value = String(editorState.strokeSize);
      }
      editorState.tool = editorTools.brush;
      editorState.isLoaded = false;
      editorState.isDrawing = false;
      editorState.draftObject = null;
      editorState.draggingObjectId = null;
      editorState.dragBaseObject = null;
      editorState.dragMoved = false;
      editorState.dragMode = null;
      editorState.dragHandle = null;
      editorState.dragHandleStartAngle = 0;
      editorState.dragHandleStartDistance = 0;
      editorState.dragHandleStartScale = 1;
      editorState.pointerId = null;
      editorState.selectedObjectId = null;
      editorState.history = [];
      editorState.objects = [];
      editorState.objectIdCounter = 1;
      imageEditorSizeText.textContent = String(editorState.strokeSize);

      try {
        const loaded = await new Promise((resolve, reject) => {
          const image = new Image();
          image.crossOrigin = "anonymous";
          image.onload = () => resolve(image);
          image.onerror = () => reject(new Error("Failed to load image."));
          image.src = imageState.url;
        });

        editorState.image = loaded;
        editorState.naturalWidth = loaded.naturalWidth || loaded.width || 1;
        editorState.naturalHeight = loaded.naturalHeight || loaded.height || 1;
        imageEditorCanvas.width = editorState.naturalWidth;
        imageEditorCanvas.height = editorState.naturalHeight;
        editorState.context = imageEditorCanvas.getContext("2d");
        editorState.filename = imageState.filename || "image";
        renderImageEditor();
        pushEditorHistory();
        editorState.isLoaded = true;
        editorState.isOpen = true;
        setImageEditorTool(editorTools.brush);
      } catch (err) {
        setImageEditorStatus("Failed to open editor.");
        applyCopyStatus(err.message || "Failed to open image editor.", true);
        closeImageEditor();
      }
    };

    const getDistance = (x1, y1, x2, y2) => {
      const dx = x1 - x2;
      const dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    };

    const getDistanceToSegment = (pointX, pointY, x1, y1, x2, y2) => {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) {
        return getDistance(pointX, pointY, x1, y1);
      }
      const t = ((pointX - x1) * dx + (pointY - y1) * dy) / (dx * dx + dy * dy);
      const clamped = Math.max(0, Math.min(1, t));
      const nearestX = x1 + clamped * dx;
      const nearestY = y1 + clamped * dy;
      return getDistance(pointX, pointY, nearestX, nearestY);
    };

    const getEditorObjectScale = (object) => Math.max(IMAGE_EDITOR_MIN_SCALE, object?.scale == null ? 1 : object.scale);
    const getEditorObjectRotation = (object) => (object?.rotation == null ? 0 : object.rotation);
    const getObjectCenter = (object) => {
      if (!object) return { x: 0, y: 0 };
      if (object.type === editorTools.text) {
        const textBounds = (() => {
          const context = editorState.context;
          if (!context) return null;
          const size = object.fontSize || 16;
          context.save();
          context.font = `${size}px Arial, sans-serif`;
          const metrics = context.measureText(object.text || "");
          context.restore();
          const width = Math.max(1, metrics.width);
          const height = Math.max(1, size);
          return { width, height };
        })();
        const width = textBounds?.width || 60;
        const height = textBounds?.height || 12;
        return {
          x: object.x + width / 2,
          y: object.y + height / 2,
        };
      }
      if (object.type === editorTools.line) {
        return {
          x: (object.x1 + object.x2) / 2,
          y: (object.y1 + object.y2) / 2,
        };
      }
      if (object.type === editorTools.rect) {
        const normalized = normalizeRect(object.x, object.y, object.width, object.height);
        return {
          x: normalized.x + normalized.width / 2,
          y: normalized.y + normalized.height / 2,
        };
      }
      if (object.type === editorTools.brush && object.points?.length) {
        let minX = object.points[0].x;
        let minY = object.points[0].y;
        let maxX = object.points[0].x;
        let maxY = object.points[0].y;
        object.points.forEach((point) => {
          if (point.x < minX) minX = point.x;
          if (point.y < minY) minY = point.y;
          if (point.x > maxX) maxX = point.x;
          if (point.y > maxY) maxY = point.y;
        });
        return {
          x: (minX + maxX) / 2,
          y: (minY + maxY) / 2,
        };
      }
      return {
        x: 0,
        y: 0,
      };
    };

    const toEditorLocalPoint = (object, position) => {
      if (!object || !position) return null;
      const center = getObjectCenter(object);
      const scale = getEditorObjectScale(object);
      const rotation = getEditorObjectRotation(object);
      const dx = position.x - center.x;
      const dy = position.y - center.y;
      const cos = Math.cos(-rotation);
      const sin = Math.sin(-rotation);
      return {
        x: (dx * cos - dy * sin) / scale,
        y: (dx * sin + dy * cos) / scale,
      };
    };

    const toEditorWorldPoint = (object, point) => {
      if (!object || !point) return null;
      const center = getObjectCenter(object);
      const scale = getEditorObjectScale(object);
      const rotation = getEditorObjectRotation(object);
      const x = point.x * scale;
      const y = point.y * scale;
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      return {
        x: center.x + x * cos - y * sin,
        y: center.y + x * sin + y * cos,
      };
    };

    const getObjectLineWidth = (object) => Math.max(0.1, object?.lineWidth || editorState.strokeSize);
    const getObjectBoundsLocal = (object) => {
      if (!object) return null;
      if (object.type === editorTools.brush) {
        if (!object.points?.length) return null;
        const centeredPoints = object.points.map((point) => {
          const local = toEditorLocalPoint({ ...object, rotation: 0, scale: 1 }, point);
          return {
            x: local?.x ?? 0,
            y: local?.y ?? 0,
          };
        });
        const minX = Math.min(...centeredPoints.map((point) => point.x));
        const minY = Math.min(...centeredPoints.map((point) => point.y));
        const maxX = Math.max(...centeredPoints.map((point) => point.x));
        const maxY = Math.max(...centeredPoints.map((point) => point.y));
        return {
          x: minX - getObjectLineWidth(object) / 2,
          y: minY - getObjectLineWidth(object) / 2,
          width: Math.max(1, maxX - minX + getObjectLineWidth(object)),
          height: Math.max(1, maxY - minY + getObjectLineWidth(object)),
        };
      }
      if (object.type === editorTools.line) {
        const p1 = toEditorLocalPoint({ ...object, rotation: 0, scale: 1 }, { x: object.x1, y: object.y1 });
        const p2 = toEditorLocalPoint({ ...object, rotation: 0, scale: 1 }, { x: object.x2, y: object.y2 });
        if (!p1 || !p2) return null;
        const w = getObjectLineWidth(object);
        return {
          x: Math.min(p1.x, p2.x) - w / 2,
          y: Math.min(p1.y, p2.y) - w / 2,
          width: Math.abs(p2.x - p1.x) + w,
          height: Math.abs(p2.y - p1.y) + w,
        };
      }
      if (object.type === editorTools.rect) {
        const normalized = normalizeRect(object.x, object.y, object.width, object.height);
        const center = getObjectCenter(object);
        const localX = normalized.x - center.x;
        const localY = normalized.y - center.y;
        const w = getObjectLineWidth(object);
        return {
          x: localX - w / 2,
          y: localY - w / 2,
          width: Math.max(1, normalized.width + w),
          height: Math.max(1, normalized.height + w),
        };
      }
      if (object.type === editorTools.text) {
        const context = editorState.context;
        if (!context) return null;
        const fontSize = object.fontSize || 16;
        context.save();
        context.font = `${fontSize}px Arial, sans-serif`;
        const metrics = context.measureText(object.text || "");
        context.restore();
        const w = Math.max(1, metrics.width);
        const h = Math.max(1, fontSize);
        return {
          x: object.x - getObjectCenter(object).x - w / 2 - 6,
          y: object.y - getObjectCenter(object).y - 6,
          width: w + 12,
          height: h + 12,
        };
      }
      return null;
    };

    const getObjectBounds = (object) => {
      const local = getObjectBoundsLocal(object);
      if (!local) return null;
      if (Math.abs(object.rotation || 0) < 0.0001 && getEditorObjectScale(object) === 1) {
        const center = getObjectCenter(object);
        return {
          x: local.x + center.x,
          y: local.y + center.y,
          width: local.width,
          height: local.height,
        };
      }
      const corners = [
        { x: local.x, y: local.y },
        { x: local.x + local.width, y: local.y },
        { x: local.x + local.width, y: local.y + local.height },
        { x: local.x, y: local.y + local.height },
      ];
      const points = corners.map((corner) => toEditorWorldPoint(object, corner));
      const valid = points.filter(Boolean);
      if (!valid.length) return null;
      return {
        x: Math.min(...valid.map((point) => point.x)),
        y: Math.min(...valid.map((point) => point.y)),
        width: Math.max(...valid.map((point) => point.x)) - Math.min(...valid.map((point) => point.x)),
        height: Math.max(...valid.map((point) => point.y)) - Math.min(...valid.map((point) => point.y)),
      };
    };

    const isPointInsideBrushObject = (object, position) => {
      const local = toEditorLocalPoint(object, position);
      if (!local || !object.points?.length) return false;
      const localLineWidth = getObjectLineWidth(object) / getEditorObjectScale(object);
      const hitTolerance = Math.max(IMAGE_EDITOR_HIT_TOLERANCE, localLineWidth + 2);
      const normalizedPoints = object.points.map((point) => toEditorLocalPoint({ ...object, rotation: 0, scale: 1 }, point));
      const localPoints = normalizedPoints.filter(Boolean);
      if (!localPoints.length) return false;
      if (localPoints.length === 1) {
        const point = localPoints[0];
        return getDistance(local.x, local.y, point.x, point.y) <= hitTolerance;
      }
      for (let index = 1; index < localPoints.length; index += 1) {
        const start = localPoints[index - 1];
        const end = localPoints[index];
        if (getDistanceToSegment(local.x, local.y, start.x, start.y, end.x, end.y) <= hitTolerance) {
          return true;
        }
      }
      return false;
    };

    const isPointInsideLineObject = (object, position) => {
      const local = toEditorLocalPoint(object, position);
      if (!local) return false;
      const p1 = toEditorLocalPoint({ ...object, rotation: 0, scale: 1 }, { x: object.x1, y: object.y1 });
      const p2 = toEditorLocalPoint({ ...object, rotation: 0, scale: 1 }, { x: object.x2, y: object.y2 });
      if (!p1 || !p2) return false;
      const localLineWidth = getObjectLineWidth(object) / getEditorObjectScale(object);
      const hitTolerance = Math.max(IMAGE_EDITOR_HIT_TOLERANCE, localLineWidth + 2);
      return getDistanceToSegment(local.x, local.y, p1.x, p1.y, p2.x, p2.y) <= hitTolerance;
    };

    const isPointInsideRectObject = (object, position) => {
      const local = toEditorLocalPoint(object, position);
      const localBounds = getObjectBoundsLocal(object);
      if (!local || !localBounds) return false;
      const localLineWidth = getObjectLineWidth(object) / getEditorObjectScale(object);
      const hitTolerance = Math.max(IMAGE_EDITOR_HIT_TOLERANCE, localLineWidth + 2);
      return (
        local.x >= localBounds.x - hitTolerance
        && local.x <= localBounds.x + localBounds.width + hitTolerance
        && local.y >= localBounds.y - hitTolerance
        && local.y <= localBounds.y + localBounds.height + hitTolerance
      );
    };

    const isPointInsideTextObject = (object, position) => {
      const local = toEditorLocalPoint(object, position);
      const localBounds = getObjectBoundsLocal(object);
      if (!local || !localBounds) return false;
      const fontScale = Math.max(0.1, 1 / getEditorObjectScale(object));
      const hitTolerance = Math.max(IMAGE_EDITOR_HIT_TOLERANCE, 6 * fontScale);
      return (
        local.x >= localBounds.x - hitTolerance
        && local.x <= localBounds.x + localBounds.width + hitTolerance
        && local.y >= localBounds.y - hitTolerance
        && local.y <= localBounds.y + localBounds.height + hitTolerance
      );
    };

    const isPointInEditorObject = (object, position) => {
      if (!object || !position) return false;
      if (object.type === editorTools.brush) return isPointInsideBrushObject(object, position);
      if (object.type === editorTools.line) return isPointInsideLineObject(object, position);
      if (object.type === editorTools.rect) return isPointInsideRectObject(object, position);
      if (object.type === editorTools.text) return isPointInsideTextObject(object, position);
      return false;
    };

    const hitTestEditorObject = (position) => {
      for (let index = editorState.objects.length - 1; index >= 0; index -= 1) {
        const object = editorState.objects[index];
        if (isPointInEditorObject(object, position)) {
          return object;
        }
      }
      return null;
    };

    const applyEditorObjectStyle = (context, object) => {
      context.strokeStyle = object.color;
      context.fillStyle = object.color;
      context.lineWidth = getObjectLineWidth(object);
      context.lineCap = "round";
      context.lineJoin = "round";
    };

    const renderEditorObject = (context, object) => {
      if (!object) return;
      const center = getObjectCenter(object);
      const rotation = getEditorObjectRotation(object);
      const scale = getEditorObjectScale(object);
      applyEditorObjectStyle(context, object);
      context.save();
      context.translate(center.x, center.y);
      if (rotation !== 0) context.rotate(rotation);
      if (scale !== 1) context.scale(scale, scale);
      if (object.type === editorTools.brush) {
        if (!object.points?.length) {
          context.restore();
          return;
        }
        const normalizedPoints = object.points.map((point) => ({
          x: point.x - center.x,
          y: point.y - center.y,
        }));
        context.beginPath();
        const first = normalizedPoints[0];
        context.moveTo(first.x, first.y);
        normalizedPoints.slice(1).forEach((point) => {
          context.lineTo(point.x, point.y);
        });
        context.stroke();
      } else if (object.type === editorTools.line) {
        const start = {
          x: object.x1 - center.x,
          y: object.y1 - center.y,
        };
        const end = {
          x: object.x2 - center.x,
          y: object.y2 - center.y,
        };
        context.beginPath();
        context.moveTo(start.x, start.y);
        context.lineTo(end.x, end.y);
        context.stroke();
      } else if (object.type === editorTools.rect) {
        const normalized = normalizeRect(object.x, object.y, object.width, object.height);
        context.strokeRect(normalized.x - center.x, normalized.y - center.y, normalized.width, normalized.height);
      } else if (object.type === editorTools.text) {
        const fontSize = object.fontSize || 16;
        context.font = `${fontSize}px Arial, sans-serif`;
        context.textBaseline = "top";
        context.fillText(object.text || "", object.x - center.x, object.y - center.y);
      }
      context.restore();
    };

    const renderEditorSelection = (context, object) => {
      const bounds = getObjectBounds(object);
      if (!bounds) return;
      const worldScale = getEditorObjectScale(object);
      const local = getObjectBoundsLocal(object);
      const selectionPadding = 4;
      const rotateHandleOffset = 24;
      const localHandle = Math.max(5, IMAGE_EDITOR_HANDLE_SIZE / Math.max(worldScale, 0.2));
      const rotationHandleOffset = Math.max(12, rotateHandleOffset / Math.max(worldScale, 0.2));
      const center = getObjectCenter(object);
      const rotation = getEditorObjectRotation(object);
      if (local) {
        context.save();
        context.translate(center.x, center.y);
        context.rotate(rotation);
        context.scale(worldScale, worldScale);
        context.setLineDash([6, 4]);
        context.strokeStyle = "rgba(95, 209, 255, 0.9)";
        context.lineWidth = 1 / worldScale;
        context.strokeRect(
          local.x - selectionPadding / worldScale,
          local.y - selectionPadding / worldScale,
          local.width + (selectionPadding * 2) / worldScale,
          local.height + (selectionPadding * 2) / worldScale,
        );
        context.setLineDash([]);
        context.fillStyle = "rgba(95, 209, 255, 0.15)";
        context.fillRect(
          local.x - 3 / worldScale,
          local.y - 3 / worldScale,
          local.width + 6 / worldScale,
          local.height + 6 / worldScale,
        );

        const handles = [
          { x: local.x, y: local.y },
          { x: local.x + local.width, y: local.y },
          { x: local.x + local.width, y: local.y + local.height },
          { x: local.x, y: local.y + local.height },
        ];
        const rotateHandle = {
          x: local.x + local.width / 2,
          y: local.y - rotationHandleOffset / worldScale,
        };
        context.fillStyle = "#f7fbff";
        handles.forEach((handle) => {
          context.fillRect(handle.x - localHandle / 2, handle.y - localHandle / 2, localHandle, localHandle);
        });
        context.fillRect(
          rotateHandle.x - localHandle / 2,
          rotateHandle.y - localHandle / 2,
          localHandle,
          localHandle,
        );
        context.restore();
        return;
      }
      context.save();
      context.setLineDash([6, 4]);
      context.strokeStyle = "rgba(95, 209, 255, 0.9)";
      context.lineWidth = 1;
      context.strokeRect(bounds.x - 4, bounds.y - 4, bounds.width + 8, bounds.height + 8);
      context.setLineDash([]);
      context.fillStyle = "rgba(95, 209, 255, 0.15)";
      context.fillRect(bounds.x - 3, bounds.y - 3, bounds.width + 6, bounds.height + 6);
      context.restore();
    };

    const moveEditorObject = (object, baseObject, deltaX, deltaY) => {
      if (!object || !baseObject) return;
      if (object.type === editorTools.brush) {
        object.points = (baseObject.points || []).map((point) => ({
          x: point.x + deltaX,
          y: point.y + deltaY,
        }));
      } else if (object.type === editorTools.line) {
        object.x1 = baseObject.x1 + deltaX;
        object.y1 = baseObject.y1 + deltaY;
        object.x2 = baseObject.x2 + deltaX;
        object.y2 = baseObject.y2 + deltaY;
      } else if (object.type === editorTools.rect) {
        object.x = baseObject.x + deltaX;
        object.y = baseObject.y + deltaY;
      } else if (object.type === editorTools.text) {
        object.x = baseObject.x + deltaX;
        object.y = baseObject.y + deltaY;
      }
    };

    const getSelectionHandleForPosition = (object, position) => {
      if (!object || !position) return null;
      const local = toEditorLocalPoint(object, position);
      const localBounds = getObjectBoundsLocal(object);
      if (!local || !localBounds) return null;
      const worldScale = getEditorObjectScale(object);
      const handleSize = Math.max(6, IMAGE_EDITOR_HANDLE_SIZE / Math.max(worldScale, 0.2));
      const hitRadius = Math.max(IMAGE_EDITOR_HANDLE_TOLERANCE / Math.max(worldScale, 0.2), handleSize);
      const rotateOffset = Math.max(18, 22 / Math.max(worldScale, 0.2));
      const rotatePoint = {
        x: localBounds.x + localBounds.width / 2,
        y: localBounds.y - rotateOffset,
      };
      const corners = [
        { id: "scale", x: localBounds.x, y: localBounds.y },
        { id: "scale", x: localBounds.x + localBounds.width, y: localBounds.y },
        { id: "scale", x: localBounds.x + localBounds.width, y: localBounds.y + localBounds.height },
        { id: "scale", x: localBounds.x, y: localBounds.y + localBounds.height },
      ];
      for (const handle of corners) {
        if (
          local.x >= handle.x - hitRadius
          && local.x <= handle.x + hitRadius
          && local.y >= handle.y - hitRadius
          && local.y <= handle.y + hitRadius
        ) {
          return "scale";
        }
      }
      if (
        local.x >= rotatePoint.x - hitRadius
        && local.x <= rotatePoint.x + hitRadius
        && local.y >= rotatePoint.y - hitRadius
        && local.y <= rotatePoint.y + hitRadius
      ) {
        return "rotate";
      }
      return null;
    };

    const getEditorPointerPosition = (event) => {
      if (!imageEditorCanvas || !editorState.naturalWidth || !editorState.naturalHeight) {
        return null;
      }
      const source = event;
      const rect = imageEditorCanvas.getBoundingClientRect();
      if (!source || source.clientX == null || source.clientY == null) {
        return null;
      }
      const scaleX = editorState.naturalWidth / rect.width;
      const scaleY = editorState.naturalHeight / rect.height;
      const x = Math.max(0, Math.min(editorState.naturalWidth - 1, (source.clientX - rect.left) * scaleX));
      const y = Math.max(0, Math.min(editorState.naturalHeight - 1, (source.clientY - rect.top) * scaleY));
      return {
        x,
        y,
        clientX: source.clientX,
        clientY: source.clientY,
      };
    };

    const deleteSelectedEditorObject = () => {
      if (!editorState.selectedObjectId) {
        setImageEditorStatus("No selected object.");
        return;
      }
      const next = editorState.objects.filter((object) => object.id !== editorState.selectedObjectId);
      if (next.length === editorState.objects.length) {
        setImageEditorStatus("Object not found.");
        return;
      }
      editorState.objects = next;
      editorState.selectedObjectId = null;
      pushEditorHistory();
      renderImageEditor();
      setImageEditorStatus("Object deleted.");
    };

    function handleEditorPointerMove(event) {
      if (!editorState.isLoaded || !editorState.context || !editorState.isDrawing) return;
      if (editorState.pointerId != null && event.pointerId !== editorState.pointerId) return;
      const position = getEditorPointerPosition(event);
      if (!position) return;
      event.preventDefault();

      const movingObject = editorState.objects.find((object) => object.id === editorState.draggingObjectId);
      if (movingObject && editorState.dragBaseObject) {
        if (editorState.dragMode === "move") {
          const deltaX = position.x - editorState.dragStartX;
          const deltaY = position.y - editorState.dragStartY;
          const moveDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          if (moveDistance < IMAGE_EDITOR_MIN_MOVE_PX) return;
          editorState.dragMoved = true;
          moveEditorObject(movingObject, editorState.dragBaseObject, deltaX, deltaY);
          renderImageEditor();
          return;
        }
        if (editorState.dragMode === "scale") {
          const local = toEditorLocalPoint(editorState.dragBaseObject, position);
          if (!local) return;
          const distance = Math.max(4, Math.hypot(local.x, local.y));
          const nextScale = Math.min(
            IMAGE_EDITOR_MAX_SCALE,
            Math.max(IMAGE_EDITOR_MIN_SCALE, editorState.dragHandleStartScale * (distance / editorState.dragHandleStartDistance)),
          );
          movingObject.scale = nextScale;
          editorState.dragMoved = true;
          renderImageEditor();
          return;
        }
        if (editorState.dragMode === "rotate") {
          const local = toEditorLocalPoint(editorState.dragBaseObject, position);
          if (!local) return;
          const angle = Math.atan2(local.y, local.x);
          const nextRotation = editorState.dragHandleStartRotation + (angle - editorState.dragHandleStartAngle);
          movingObject.rotation = nextRotation % (Math.PI * 2);
          editorState.dragMoved = true;
          renderImageEditor();
          return;
        }
      }

      if (!editorState.draftObject) return;
      if (editorState.draftObject.type === editorTools.brush) {
        const last = editorState.draftObject.points[editorState.draftObject.points.length - 1];
        const dx = position.x - last.x;
        const dy = position.y - last.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < IMAGE_EDITOR_MIN_MOVE_PX) return;
        editorState.draftObject.points.push(position);
      } else if (editorState.draftObject.type === editorTools.line) {
        const dx = position.x - editorState.startX;
        const dy = position.y - editorState.startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < IMAGE_EDITOR_MIN_MOVE_PX) return;
        editorState.draftObject.x2 = position.x;
        editorState.draftObject.y2 = position.y;
      } else if (editorState.draftObject.type === editorTools.rect) {
        const dx = position.x - editorState.startX;
        const dy = position.y - editorState.startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < IMAGE_EDITOR_MIN_MOVE_PX) return;
        editorState.draftObject.width = position.x - editorState.draftObject.x;
        editorState.draftObject.height = position.y - editorState.draftObject.y;
      }
      renderImageEditor();
    }

    function handleEditorPointerUp(event) {
      if (!editorState.isLoaded || !editorState.context || event.pointerId == null) return;
      if (editorState.pointerId != null && event.pointerId !== editorState.pointerId) return;
      const movingObjectId = editorState.draggingObjectId;
      const draftObject = editorState.draftObject;

      if (editorState.pointerId != null && event.pointerId === editorState.pointerId) {
        try {
          imageEditorCanvas?.releasePointerCapture(editorState.pointerId);
        } catch (_) {
          // ignore
        }
        editorState.pointerId = null;
      }

      if (!editorState.isDrawing && !movingObjectId && !draftObject) {
        return;
      }

      editorState.isDrawing = false;
      editorState.draggingObjectId = null;
      editorState.draftObject = null;

      if (movingObjectId && editorState.dragBaseObject) {
        const dragMode = editorState.dragMode;
        editorState.dragBaseObject = null;
        if (editorState.dragMoved) {
          if (dragMode === "scale") {
            setImageEditorStatus("Object resized.");
          } else if (dragMode === "rotate") {
            setImageEditorStatus("Object rotated.");
          } else {
            setImageEditorStatus("Object moved.");
          }
          pushEditorHistory();
        } else {
          setImageEditorStatus("Object selected.");
        }
        editorState.dragMode = null;
        editorState.dragHandle = null;
        editorState.dragMoved = false;
        editorState.dragHandleStartAngle = 0;
        editorState.dragHandleStartDistance = 0;
        editorState.dragHandleStartScale = 1;
        return;
      }

      if (!draftObject) {
        return;
      }

      if (draftObject.type === editorTools.brush && draftObject.points.length <= 1) {
        setImageEditorStatus("No change.");
        return;
      }
      if (draftObject.type === editorTools.line && draftObject.x1 === draftObject.x2 && draftObject.y1 === draftObject.y2) {
        setImageEditorStatus("No change.");
        return;
      }
      if (draftObject.type === editorTools.rect && draftObject.width === 0 && draftObject.height === 0) {
        setImageEditorStatus("No change.");
        return;
      }

      editorState.objects.push(draftObject);
      editorState.selectedObjectId = draftObject.id;
      pushEditorHistory();
      renderImageEditor();
      setImageEditorTool(editorTools.select);
      setImageEditorStatus("Object added.");
    }

    function handleEditorPointerDown(event) {
      if (!editorState.isLoaded || !editorState.context) return;
      if (event.button != null && event.button !== 0) return;
      if (editorState.pointerId != null) return;
      if (editorState.isTextInputOpen) {
        hideImageEditorTextInput();
      }
      const position = getEditorPointerPosition(event);
      if (!position) return;
      event.preventDefault();

      if (event.pointerId != null) {
        editorState.pointerId = event.pointerId;
        try {
          imageEditorCanvas?.setPointerCapture(event.pointerId);
        } catch (_) {
          // ignore
        }
      }

      if (editorState.tool === editorTools.text) {
        editorState.startX = position.x;
        editorState.startY = position.y;
        const hitObject = hitTestEditorObject(position);
        if (hitObject?.type === editorTools.text) {
          openImageEditorTextInput(position, hitObject);
          return;
        }

        openImageEditorTextInput(position);
        return;
      }

      const hitObject = hitTestEditorObject(position);
      if (IMAGE_EDITOR_HANDLE_DEBUG) {
        console.debug("[ImageEditorHandle] pointerdown", {
          position,
          selectedObjectId: editorState.selectedObjectId,
          hitObjectId: hitObject ? hitObject.id : null,
        });
      }
      if (editorState.tool === editorTools.select) {
        const selectedObject = editorState.selectedObjectId
          ? editorState.objects.find((object) => object.id === editorState.selectedObjectId) || null
          : null;
        const selectedHandle = selectedObject ? getSelectionHandleForPosition(selectedObject, position) : null;
        const directHandle = hitObject ? getSelectionHandleForPosition(hitObject, position) : null;
        if (IMAGE_EDITOR_HANDLE_DEBUG) {
          console.debug("[ImageEditorHandle] checks", {
            selectedObjectId: selectedObject ? selectedObject.id : null,
            selectedHandle,
            hitObjectId: hitObject ? hitObject.id : null,
            directHandle,
          });
        }
        const handle = selectedHandle || directHandle;
        const handleOwner = selectedHandle ? selectedObject : hitObject;
        if (handle && handleOwner) {
          editorState.isDrawing = true;
          editorState.draggingObjectId = handleOwner.id;
          editorState.dragBaseObject = cloneEditorObject(handleOwner);
          editorState.dragMode = handle;
          editorState.dragHandle = handle;
          editorState.dragStartX = position.x;
          editorState.dragStartY = position.y;
          editorState.startX = position.x;
          editorState.startY = position.y;
          editorState.dragMoved = false;
          editorState.dragHandleStartScale = getEditorObjectScale(handleOwner);
          editorState.dragHandleStartRotation = getEditorObjectRotation(handleOwner);
          if (handle === "rotate") {
            const local = toEditorLocalPoint(handleOwner, position);
            editorState.dragHandleStartAngle = local ? Math.atan2(local.y, local.x) : 0;
            editorState.dragHandleStartDistance = 1;
          } else {
            const local = toEditorLocalPoint(handleOwner, position);
            editorState.dragHandleStartDistance = local ? Math.hypot(local.x, local.y) : 1;
          }
          renderImageEditor();
          setImageEditorStatus(handle === "rotate" ? "Rotate mode." : "Scale mode.");
          return;
        }
        if (!hitObject) {
          editorState.selectedObjectId = null;
          renderImageEditor();
          setImageEditorStatus("Select mode: click an object to move.");
          return;
        }
        editorState.selectedObjectId = hitObject.id;
      }

      if (hitObject) {
        editorState.isDrawing = true;
        editorState.draggingObjectId = hitObject.id;
        editorState.dragBaseObject = cloneEditorObject(hitObject);
        editorState.dragMode = "move";
        editorState.dragStartX = position.x;
        editorState.dragStartY = position.y;
        editorState.startX = position.x;
        editorState.startY = position.y;
        editorState.dragMoved = false;
        editorState.selectedObjectId = hitObject.id;
        renderImageEditor();
        setImageEditorStatus("Object selected. Drag to move, Delete to remove.");
        return;
      }

      editorState.startX = position.x;
      editorState.startY = position.y;

      const draftObject = {
        id: createEditorObjectId(),
        type: editorState.tool,
        color: editorState.color,
        lineWidth: editorState.strokeSize,
        rotation: 0,
        scale: 1,
      };
      if (editorState.tool === editorTools.brush) {
        draftObject.points = [position];
      } else if (editorState.tool === editorTools.line) {
        draftObject.x1 = position.x;
        draftObject.y1 = position.y;
        draftObject.x2 = position.x;
        draftObject.y2 = position.y;
      } else {
        draftObject.x = position.x;
        draftObject.y = position.y;
        draftObject.width = 0;
        draftObject.height = 0;
      }
      editorState.draftObject = draftObject;
      editorState.isDrawing = true;
      setImageEditorStatus("Drawing...");
      renderImageEditor();
    }

    const undoImageEdit = () => {
      if (editorState.history.length <= 1) {
        setImageEditorStatus("Nothing to undo.");
        return;
      }
      editorState.history.pop();
      restoreEditorFromHistory(editorState.history.length - 1);
      setImageEditorStatus("Undo done.");
    };

    const clearImageEdit = () => {
      editorState.objects = [];
      editorState.selectedObjectId = null;
      pushEditorHistory();
      renderImageEditor();
      setImageEditorStatus("All objects cleared.");
    };

    const uploadEditedImage = async () => {
      if (!editorState.context || !editorState.isLoaded) return;
      if (imageEditorSaveBtn) imageEditorSaveBtn.disabled = true;
      try {
        const blob = await new Promise((resolve) => {
          imageEditorCanvas.toBlob((value) => resolve(value), "image/png", 0.98);
        });
        if (!blob) {
          throw new Error("Failed to generate edited image.");
        }
        const stem = editorState.filename.replace(/\.[^.]+$/, "") || "image";
        const file = new File([blob], `${stem}-edited.png`, { type: "image/png" });
        const result = await uploadSingleFile(file);
        applyUploadedFileToUi(result);
        await loadRecentUploads();
        galleryNeedsRefresh = true;
        if (activeTab === "gallery") {
          await resetList();
          galleryNeedsRefresh = false;
        } else {
          setUploadStatus("Edited image uploaded.");
        }
        closeImageEditor();
        applyCopyStatus("Edited image uploaded.");
      } catch (err) {
        applyCopyStatus(err.message || "Failed to save edited image.", true);
      } finally {
        if (imageEditorSaveBtn) imageEditorSaveBtn.disabled = false;
      }
    };

    const closeImageEditor = () => {
      hideImageEditorTextInput();
      if (editorState.context) {
        editorState.context = null;
      }
      editorState.isLoaded = false;
      editorState.isDrawing = false;
      editorState.draftObject = null;
      editorState.draggingObjectId = null;
      editorState.dragBaseObject = null;
      editorState.dragMoved = false;
      editorState.dragMode = null;
      editorState.dragHandle = null;
      editorState.dragHandleStartAngle = 0;
      editorState.dragHandleStartDistance = 0;
      editorState.dragHandleStartScale = 1;
      editorState.pointerId = null;
      editorState.history = [];
      editorState.selectedObjectId = null;
      editorState.objects = [];
      editorState.image = null;
      editorState.isOpen = false;
      if (imageEditorCanvas) imageEditorCanvas.hidden = true;
      if (imageEditor) imageEditor.setAttribute("aria-hidden", "true");
      if (imageModalImg) imageModalImg.hidden = false;
      if (imageModalEditBtn) imageModalEditBtn.disabled = false;
      setImageEditorStatus("");
    };

    function syncImageEditorInputs() {
      editorState.color = imageEditorColorInput?.value || editorState.color;
      editorState.strokeSize = parseInt(imageEditorSizeInput?.value, 10) || editorState.strokeSize;
      imageEditorSizeText.textContent = String(editorState.strokeSize);
      if (editorState.selectedObjectId) {
        const selected = editorState.objects.find((object) => object.id === editorState.selectedObjectId);
        if (selected) {
          selected.color = editorState.color;
          if (selected.type === editorTools.text) {
            selected.fontSize = Math.max(12, Math.round(editorState.strokeSize * 3));
          } else {
            selected.lineWidth = editorState.strokeSize;
          }
          renderImageEditor();
        }
      }
      setImageEditorStatus(`Color: ${editorState.color}, Size: ${editorState.strokeSize}`);
    }

    const renderGridItem = (item) => {
      const row = document.createElement("div");
      row.className = "item";

      const main = document.createElement("div");
      main.className = "item-main gallery-item-main";
      const select = createGallerySelectInput(item);

      const thumb = document.createElement("img");
      thumb.src = item.thumbnail_url || item.url;
      thumb.className = "thumb";
      thumb.loading = "lazy";
      thumb.alt = item.filename;
      thumb.addEventListener("click", () => openImageModal(item));

      const content = document.createElement("div");
      content.className = "item-content";

      const actions = document.createElement("div");
      actions.className = "item-row";

      const link = document.createElement("a");
      link.href = item.url;
      link.target = "_blank";
      link.rel = "noreferrer";
      link.className = "item-link";
      link.textContent = item.filename;

      const copy = document.createElement("button");
      copy.type = "button";
      copy.className = "small-btn btn";
      copy.textContent = "Copy URL";
      copy.addEventListener("click", async () => {
        try {
          await copyImageUrlToClipboard(item);
        } catch (err) {
          applyCopyStatus(err.message || "Copy URL failed.", true);
        }
      });

      const copyImage = document.createElement("button");
      copyImage.type = "button";
      copyImage.className = "small-btn secondary";
      copyImage.textContent = "Copy Image";
      copyImage.addEventListener("click", async () => {
        try {
          await copyImageFileToClipboard(item);
        } catch (err) {
          applyCopyStatus(err.message || "Copy image failed.", true);
        }
      });

      const del = document.createElement("button");
      del.type = "button";
      del.className = "small-btn danger";
      del.textContent = "Delete";
      del.addEventListener("click", () => {
        openDeleteModal(item, row, del);
      });
      const meta = document.createElement("div");
      const ttl = item.ttl_seconds_remaining === null
        ? "ttl: n/a"
        : `ttl: ${item.ttl_seconds_remaining}s`;
      const created = formatCreatedAt(item.created_at);
      meta.textContent = `size ${formatBytes(item.size_bytes)} | ${created} | ${ttl}`;
      actions.appendChild(link);
      actions.appendChild(copy);
      actions.appendChild(copyImage);
      actions.appendChild(del);
      content.appendChild(actions);
      content.appendChild(meta);
      main.appendChild(select);
      main.appendChild(thumb);
      main.appendChild(content);
      row.appendChild(main);
      return row;
    };

    const renderListItem = (item) => {
      const row = document.createElement("div");
      row.className = "item";

      const select = createGallerySelectInput(item);

      const thumb = document.createElement("img");
      thumb.src = item.thumbnail_url || item.url;
      thumb.className = "thumb";
      thumb.loading = "lazy";
      thumb.alt = item.filename;
      thumb.addEventListener("click", () => openImageModal(item));

      const content = document.createElement("div");
      content.className = "item-content";

      const link = document.createElement("a");
      link.href = item.url;
      link.target = "_blank";
      link.rel = "noreferrer";
      link.className = "item-link";
      link.textContent = item.filename;

      const meta = document.createElement("div");
      meta.className = "item-meta";
      const ttl = item.ttl_seconds_remaining === null
        ? "ttl: n/a"
        : `ttl: ${item.ttl_seconds_remaining}s`;
      const created = formatCreatedAt(item.created_at);
      meta.textContent = `size ${formatBytes(item.size_bytes)} | ${created} | ${ttl}`;

      const actions = document.createElement("div");
      actions.className = "item-row";

      const copy = document.createElement("button");
      copy.type = "button";
      copy.className = "small-btn btn";
      copy.textContent = "Copy URL";
      copy.addEventListener("click", async () => {
        try {
          await copyImageUrlToClipboard(item);
        } catch (err) {
          applyCopyStatus(err.message || "Copy URL failed.", true);
        }
      });

      const copyImage = document.createElement("button");
      copyImage.type = "button";
      copyImage.className = "small-btn secondary";
      copyImage.textContent = "Copy Image";
      copyImage.addEventListener("click", async () => {
        try {
          await copyImageFileToClipboard(item);
        } catch (err) {
          applyCopyStatus(err.message || "Copy image failed.", true);
        }
      });

      const del = document.createElement("button");
      del.type = "button";
      del.className = "small-btn danger";
      del.textContent = "Delete";
      del.addEventListener("click", () => {
        openDeleteModal(item, row, del);
      });
      actions.appendChild(copy);
      actions.appendChild(copyImage);
      actions.appendChild(del);

      content.appendChild(link);
      content.appendChild(meta);
      content.appendChild(actions);

      const main = document.createElement("div");
      main.className = "item-main gallery-item-main";
      main.appendChild(select);
      main.appendChild(thumb);
      main.appendChild(content);
      row.appendChild(main);
      return row;
    };

    const renderItem = (item) => renderListItem(item);

    const renderRecentItem = (item) => {
      const row = document.createElement("div");
      row.className = "item";

      const thumb = document.createElement("img");
      thumb.src = item.thumbnail_url || item.url;
      thumb.className = "thumb";
      thumb.loading = "lazy";
      thumb.alt = item.filename;
      thumb.addEventListener("click", () => openImageModal(item));

      const content = document.createElement("div");
      content.className = "item-content";

      const link = document.createElement("a");
      link.href = item.url;
      link.target = "_blank";
      link.rel = "noreferrer";
      link.className = "item-link";
      link.textContent = item.filename;

      const meta = document.createElement("div");
      meta.className = "item-meta";
      const ttl = item.ttl_seconds_remaining === null
        ? "ttl: n/a"
        : `ttl: ${item.ttl_seconds_remaining}s`;
      const created = formatCreatedAt(item.created_at);
      meta.textContent = `size ${formatBytes(item.size_bytes)} | ${created} | ${ttl}`;

      const actions = document.createElement("div");
      actions.className = "item-row";

      const copy = document.createElement("button");
      copy.type = "button";
      copy.className = "small-btn btn";
      copy.textContent = "Copy URL";
      copy.addEventListener("click", async () => {
        try {
          await copyImageUrlToClipboard(item);
        } catch (err) {
          applyCopyStatus(err.message || "Copy URL failed.", true);
        }
      });

      const copyImage = document.createElement("button");
      copyImage.type = "button";
      copyImage.className = "small-btn secondary";
      copyImage.textContent = "Copy Image";
      copyImage.addEventListener("click", async () => {
        try {
          await copyImageFileToClipboard(item);
        } catch (err) {
          applyCopyStatus(err.message || "Copy image failed.", true);
        }
      });

      const del = document.createElement("button");
      del.type = "button";
      del.className = "small-btn danger";
      del.textContent = "Delete";
      del.addEventListener("click", () => {
        openDeleteModal(item, row, del);
      });
      actions.appendChild(copy);
      actions.appendChild(copyImage);
      actions.appendChild(del);
      content.appendChild(link);
      content.appendChild(meta);
      content.appendChild(actions);

      const main = document.createElement("div");
      main.className = "item-main";
      main.appendChild(thumb);
      main.appendChild(content);
      row.appendChild(main);
      return row;
    };

    const loadRecentUploads = async () => {
      if (isRecentLoading) return;
      isRecentLoading = true;
      recentList.innerHTML = "";
      recentStatus.textContent = "";
      recentStatus.classList.toggle("error", false);

      try {
        const resp = await fetch("/list?limit=3&offset=0");
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.detail || "Failed to load recent uploads.");

        if (data.items.length === 0) {
          const empty = document.createElement("div");
          empty.className = "empty";
          empty.textContent = "No uploads yet.";
          recentList.appendChild(empty);
          return;
        }

        data.items.forEach((item) => recentList.appendChild(renderRecentItem(item)));
      } catch (err) {
        recentStatus.textContent = err.message || "Failed to load recent uploads.";
        recentStatus.classList.toggle("error", true);
      } finally {
        isRecentLoading = false;
      }
    };

    const loadList = async (append = false) => {
      if (isLoading) return;
      isLoading = true;
      if (!append) {
        galleryList.innerHTML = "";
        listOffset = 0;
        gallerySelected.clear();
        galleryItemMap.clear();
      }
      setGalleryStatus("");
      loadMoreBtn.disabled = true;

      try {
        const resp = await fetch(`/list?limit=${PAGE_LIMIT}&offset=${listOffset}`);
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.detail || "Failed to load list.");

        if (!append && data.items.length === 0) {
          const empty = document.createElement("div");
          empty.className = "empty";
          empty.textContent = "No images yet.";
          galleryList.appendChild(empty);
          loadMoreBtn.disabled = true;
          gallerySummary.textContent = "0 images";
          syncGallerySelectionUi();
          return;
        }

        data.items.forEach((item) => {
          const key = getGalleryItemKey(item);
          if (key) {
            galleryItemMap.set(key, item);
          }
          galleryList.appendChild(renderItem(item));
        });
        listOffset = data.next_offset;
        gallerySummary.textContent = `${data.total} images`;
        loadMoreBtn.disabled = !data.has_more;
        loadMoreBtn.textContent = data.has_more ? "Load more" : "All loaded";
        syncGallerySelectionUi();
      } catch (err) {
        setGalleryStatus(err.message || "Failed to load list.", true);
      } finally {
        isLoading = false;
      }
    };

    const resetList = async () => {
      await loadList(false);
    };

    const uploadSingleFile = async (file) => {
      if (!allowed(file)) {
        throw new Error("Only image files are supported.");
      }

      const form = new FormData();
      form.append("file", file);

      const resp = await fetch("/upload", { method: "POST", body: form });
      const data = await resp.json();
      if (!resp.ok) {
        throw new Error(data?.detail || "Upload failed.");
      }

      return data;
    };

    const applyUploadedFileToUi = (data) => {
      urlBox.textContent = data.url;
      copyBtn.disabled = false;
      preview.src = data.url;
      previewBox.style.display = "block";
      preview.style.cursor = "zoom-in";
      preview.onclick = () => {
        openImageModal({ filename: data.filename, url: data.url });
      };
    };

    const enqueueUploadFiles = (fileList) => {
      const files = [...fileList].filter(Boolean);
      if (!files.length) return;

      const validFiles = files.filter(allowed);
      const invalidCount = files.length - validFiles.length;

      if (validFiles.length === 0) {
        setUploadStatus("Only image files are supported.");
        return;
      }

      if (invalidCount > 0) {
        setUploadStatus(`Skipped ${invalidCount} unsupported file${invalidCount > 1 ? "s" : ""}.`);
      }

      validFiles.forEach((file) => {
        uploadQueue.push(file);
      });
      if (isUploadInProgress) return;
      void processUploadQueue();
    };

    const refreshAfterUploads = async (didUploadAny) => {
      if (!didUploadAny) return;
      loadRecentUploads();
      galleryNeedsRefresh = true;
      if (activeTab === "gallery") {
        await resetList();
        galleryNeedsRefresh = false;
      }
    };

    const updateRetryButton = () => {
      if (failedUploadQueue.length > 0) {
        const count = failedUploadQueue.length;
        retryFailedBtn.textContent = `Retry ${count} failed upload${count > 1 ? "s" : ""}`;
        retryFailedBtn.hidden = false;
      } else {
        retryFailedBtn.hidden = true;
      }
    };

    const processUploadQueue = async () => {
      if (isUploadInProgress) return;
      if (uploadQueue.length === 0) {
        updateRetryButton();
        return;
      }

      const batch = [...uploadQueue];
      uploadQueue.length = 0;
      isUploadInProgress = true;
      copyBtn.disabled = true;
      previewBox.style.display = "none";
      retryFailedBtn.hidden = true;

      const failedBefore = failedUploadQueue.length;
      let successCount = 0;
      let latestData = null;
      const total = batch.length;

      for (let i = 0; i < batch.length; i += 1) {
        const file = batch[i];
        setUploadStatus(`Uploading ${i + 1}/${total}: ${file.name || "image"}`);

        try {
          const data = await uploadSingleFile(file);
          successCount += 1;
          latestData = data;
          applyUploadedFileToUi(data);
        } catch (error) {
          failedUploadQueue.push(file);
          continue;
        }
      }

      await refreshAfterUploads(successCount > 0);

      const failedInThisBatch = failedUploadQueue.length - failedBefore;

      if (successCount > 0 && latestData?.url) {
        try {
          await copyTextToClipboard(latestData.url);
          setUploadStatus(
            `${successCount}/${total} uploaded. Copied latest URL to clipboard.` +
              (failedInThisBatch > 0
                ? ` ${failedInThisBatch} failed; retry available.`
                : ""),
            failedInThisBatch > 0,
          );
        } catch (error) {
          setUploadStatus(error.message || "Uploaded, but failed to copy latest URL.", true);
        }
      } else if (failedInThisBatch > 0) {
        setUploadStatus(`Upload failed for ${failedInThisBatch} file${failedInThisBatch > 1 ? "s" : ""}.`, true);
      } else {
        setUploadStatus("Upload failed.", true);
      }

      isUploadInProgress = false;
      updateRetryButton();

      if (uploadQueue.length > 0) {
        await processUploadQueue();
      }
    };

    const retryFailedUploads = () => {
      if (!failedUploadQueue.length) return;
      const retryItems = [...failedUploadQueue];
      failedUploadQueue.length = 0;
      retryItems.forEach((file) => uploadQueue.push(file));
      void processUploadQueue();
    };

    function openImageModal(item) {
      if (!item?.url) return;
      if (editorState.isOpen) {
        closeImageEditor();
      }
      imageState = {
        filename: item.filename || "image",
        url: item.url,
      };
      imagePrevFocus.target = document.activeElement;
      imageModalFilename.textContent = imageState.filename;
      imageModalImg.src = imageState.url;
      imageModalImg.hidden = false;
      if (imageModalEditBtn) imageModalEditBtn.disabled = false;
      setImageEditorStatus("");
      imageModal.hidden = false;
      imageModal.setAttribute("aria-hidden", "false");
      window.requestAnimationFrame(() => imageModalCloseBtn.focus());
    }

    function closeImageModal() {
      if (editorState.isOpen) {
        closeImageEditor();
      }
      imageState = null;
      imageModal.hidden = true;
      imageModal.setAttribute("aria-hidden", "true");
      imageModalImg.src = "";
      if (imagePrevFocus.target && typeof imagePrevFocus.target.focus === "function") {
        imagePrevFocus.target.focus();
      }
      imagePrevFocus.target = null;
    }

    tabUpload.addEventListener("click", () => switchTab("upload"));
    tabGallery.addEventListener("click", () => switchTab("gallery"));
    copyBtn.addEventListener("click", async () => {
      if (!urlBox.textContent || !urlBox.textContent.startsWith("http")) return;
      await copyTextToClipboard(urlBox.textContent);
      setUploadStatus("Image URL copied.");
    });
    refreshBtn.addEventListener("click", () => resetList());
    gallerySelectAllBtn.addEventListener("click", () => {
      const keys = Array.from(galleryItemMap.keys());
      const allSelected = keys.length > 0 && keys.every((key) => gallerySelected.has(key));
      if (allSelected) {
        keys.forEach((key) => gallerySelected.delete(key));
      } else {
        keys.forEach((key) => gallerySelected.add(key));
      }
      syncGallerySelectionUi();
    });
    galleryDeleteSelectedBtn.addEventListener("click", openDeleteSelectedModal);
    // view mode toggle intentionally removed (always list view)
    loadMoreBtn.addEventListener("click", () => loadList(true));

    fileInput.addEventListener("change", (e) => {
      if (!e.target.files) return;
      enqueueUploadFiles(e.target.files);
      e.target.value = "";
    });

    zone.addEventListener("dragover", (e) => {
      e.preventDefault();
      zone.classList.add("drag");
    });
    zone.addEventListener("dragleave", () => zone.classList.remove("drag"));
    zone.addEventListener("drop", (e) => {
      e.preventDefault();
      zone.classList.remove("drag");
      if (!e.dataTransfer.files) return;
      enqueueUploadFiles(e.dataTransfer.files);
    });

    window.addEventListener("paste", (e) => {
      const item = [...(e.clipboardData?.items || [])].find((i) => i.type.startsWith("image/"));
      if (!item) return;
      const file = item.getAsFile();
      if (file) enqueueUploadFiles([file]);
    });
    retryFailedBtn.addEventListener("click", retryFailedUploads);

    const savedTab = localStorage.getItem("quick-clip-tab");
    setGalleryViewMode("list");
    loadRecentUploads();
    if (savedTab === "gallery") {
      switchTab("gallery");
    } else {
      switchTab("upload");
    }
  </script>
</body>
</html>

